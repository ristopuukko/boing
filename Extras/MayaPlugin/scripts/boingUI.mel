/*
Bullet Continuous Collision Detection and Physics Library Maya Plugin
Copyright (c) 2008 Walt Disney Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising
from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must
not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Nicola Candussi <nicola@fluidinteractive.com>

Modified by Roman Ponomarev <rponom@gmail.com>
01/22/2010 : Constraints reworked

Modified by Michael Baker <michael@mBakr.com>
*/
//init
global proc boingUI_initialize() //this proc is called from the plugin
{	
	print("Loading boing plugin...\n");
	
	global float $boingUI_startFrame;
	global float $boingUI_captureStartFrame;
	global float $boingUI_captureEndFrame;
	
	source "mbUtils";

	//add boing menu to the main window
	global string $gMainWindow;
	string $boingMainMenu = `menu -l "boing" -to 1 -p $gMainWindow`;
	menuItem -l "boing Window" -ann "Open the main boing window" -c "boingUI_createWindow()" -fi "boingWindow.xpm" $boingMainMenu;
	menuItem -d 1 $boingMainMenu;
	menuItem -l "Help" -ann "View the wiki online" -c "system(\"load https://code.google.com/p/dynamica/wiki/DynamicaIntroduction\")" $boingMainMenu;

	//initial settings
	$boingUI_startFrame = `playbackOptions -q -min`; //init start frame
	boingUI_onPluginLoad(); //init script jobs
	playbackOptions -e -playbackSpeed 0 -maxPlaybackSpeed 1; //set playback options
	$boingUI_captureStartFrame = `playbackOptions -q -min`;
	$boingUI_captureEndFrame = `playbackOptions -q -max`;
	boingUI_createShelf();
	
	print("Loading boing plugin...complete.\n");
}
    
//shelf
global proc boingUI_createShelf()
{
	global string $gShelfTopLevel;
	string $shelf = "boing";
	string $boingShelf;
	
	if ( `shelfLayout -ex $shelf` )
	{
		$boingShelf = $shelf;
		string $shelfButtons[] = `shelfLayout -q -ca $shelf`;
		for ( $b in $shelfButtons ) deleteUI $b;
	} 
	else 
	{
		// Create the shelf under the global shelf parent.
		$boingShelf = `shelfLayout -p $gShelfTopLevel $shelf`;
	}
	
	shelfButton -i "boingWindow.xpm" -c "boingUI_createWindow" -ann "Open Main boing Window" -p $boingShelf;
	shelfButton -i "boingRelink.xpm" -c "boingUI_relinkRigidBodies" -ann "Relink bodies to solver after copy and paste" -p $boingShelf;
	
	shelfButton -i "boingCreateActiveSphere.xpm" 
		-c "boingUI_createActiveSphere" -ann "Create an active sphere rigid body" -p $boingShelf;
	shelfButton -i "boingCreateActiveBox.xpm" 
		-c "boingUI_createActiveBox" -ann "Create an active box rigid body" -p $boingShelf;
	// shelfButton -i "boingCreateActiveCylinder.xpm" 
		// -c "boingUI_createRigidBody(true, 5)" -ann "Create an active cylinder rigid body" -p $boingShelf;
	// shelfButton -i "boingCreateActiveCapsule.xpm" 
		// -c "boingUI_createRigidBody(true, 4)" -ann "Create an active capsule rigid body" -p $boingShelf;
	shelfButton -i "boingCreateActiveHull.xpm" 
		-c "boingUI_createActiveHull" -ann "Create active hull rigid bodies" -p $boingShelf;
	shelfButton -i "boingCreateActiveMesh.xpm"
		-c "boingUI_createActiveMesh" -ann "Create active mesh rigid bodies" -p $boingShelf;
	shelfButton -i "boingCreateActiveMesh.xpm"
		-c "boingUI_createRigidBody(true, 8)" -ann "Create HACD rigid bodies" -p $boingShelf;
		
	shelfButton -i "boingCreatePassiveSphere.xpm" 
		-c "boingUI_createPassiveSphere" -ann "Create passive sphere rigid body" -p $boingShelf;
	shelfButton -i "boingCreatePassiveBox.xpm" 
		-c "boingUI_createPassiveBox" -ann "Create passive box rigid body" -p $boingShelf;
	shelfButton -i "boingCreatePassiveHull.xpm" 
		-c "boingUI_createPassiveHull" -ann "Create passive hull rigid bodies" -p $boingShelf;
	shelfButton -i "boingCreatePassiveMesh.xpm" 
		-c "boingUI_createPassiveMesh" -ann "Create passive mesh rigid bodies" -p $boingShelf;
	shelfButton -i "boingCreatePassivePlane.xpm" 
		-c "boingUI_createPassivePlane" -ann "Create passive plane rigid body" -p $boingShelf;

	shelfButton -i "boingCreateActiveMesh.xpm"
		-c "boingUI_createPassiveHACD(true, 8)" -ann "Create passive HACD rigid body" -p $boingShelf;
	
	
	
	shelfButton -i "boingCreateNailConstraint.xpm" 
		-c "boingUI_createNail" -ann "Create a breakable nail constraint" -p $boingShelf;
	shelfButton -i "boingCreateHingeConstraint.xpm" 
		-c "boingUI_createHinge" -ann "Create a breakable hinge constraint" -p $boingShelf;
	shelfButton -i "boingCreateSliderConstraint.xpm" 
		-c "boingUI_createSlider" -ann "Create a breakable slider constraint" -p $boingShelf;
	shelfButton -i "boingCreate6dofConstraint.xpm" 
		-c "boingUI_create6Dof" -ann "Create a breakable 6dof constraint" -p $boingShelf;
		
	shelfButton -i "boingSoftMesh.xpm"
		-c "boingUI_createSoftBody()" -ann "Create a softbody" -p $boingShelf;
		
	// shelfButton -i "boingCreateConetwistConstraint.xpm" 
		// -c "boingUI_createConstraint(3)" -ann "Create a breakable cone twist constraint" -p $boingShelf;
		
	// shelfButton -i "boingActivateX.xpm" 
		// -c "boingUI_activateAxis(0)" -ann "Activate selected rigid bodies along the +X axis" -p $boingShelf;
	// shelfButton -i "boingActivate-X.xpm" 
		// -c "boingUI_activateAxis(1)" -ann "Activate selected rigid bodies along the -X axis" -p $boingShelf;
	// shelfButton -i "boingActivateY.xpm" 
		// -c "boingUI_activateAxis(2)" -ann "Activate selected rigid bodies along the +Y axis" -p $boingShelf;
	// shelfButton -i "boingActivate-Y.xpm" 
		// -c "boingUI_activateAxis(3)" -ann "Activate selected rigid bodies along the -Y axis" -p $boingShelf;
	// shelfButton -i "boingActivateZ.xpm" 
		// -c "boingUI_activateAxis(4)" -ann "Activate selected rigid bodies along the +Z axis" -p $boingShelf;
	// shelfButton -i "boingActivate-Z.xpm" 
		// -c "boingUI_activateAxis(5)" -ann "Activate selected rigid bodies along the -Z axis" -p $boingShelf;
		
	// shelfButton -i "boingActivateRadial.xpm" 
		// -c "boingUI_activateAxis(6)" -ann "Activate selected rigid bodies outwards" -p $boingShelf;
	// shelfButton -i "boingActivateRadialIn.xpm" 
		// -c "boingUI_activateAxis(7)" -ann "Activate selected rigid bodies inwards" -p $boingShelf;
	// shelfButton -i "boingActivateChain.xpm" 
		// -c "boingUI_activateAxis(8)" -ann "Chain activate selected rigid bodies" -p $boingShelf;
		
	// shelfButton -i "boingUnactivate.xpm" 
		// -c "boingUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies active (restores default behavior)" -p $boingShelf;
	// shelfButton -i "boingMakePassive.xpm" 
		// -c "boingUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies passive" -p $boingShelf;
	// shelfButton -i "boingSetInitialState.xpm" 
		// -c "boingUI_setInitialState(0)" -ann "Set current state to initial state" -p $boingShelf;
	// shelfButton -i "boingClearInitialState.xpm" 
		// -c "boingUI_setInitialState(1)" -ann "Restore original initial state" -p $boingShelf;
		
	// shelfButton -i "boingBakeSelected.xpm" 
		// -c "$boingUI_captureAll = 0; boingUI_bakeRigidBodies()" -ann "Bake Selected Rigid Bodies" -p $boingShelf;
	// shelfButton -i "boingBakeAll.xpm" 
		// -c "$boingUI_captureAll = 1; boingUI_bakeRigidBodies()" -ann "Bake All Rigid Bodies" -p $boingShelf;
	
	shelfButton -i "boingHelp.xpm" -c "system(\"load https://code.google.com/p/dynamica/wiki/DynamicaIntroduction\")"
		-ann "View Online Documentation" -p $boingShelf;
	// shelfButton -i "boingTools.xpm" -c "boingUI_tools()" -ann "Open Main boingUI Window" -p $boingUIShelf;
}

//UI
global proc boingUI_createWindow()
{
	global string $boingUI_window;
	global string $boingUI_tabs;
	global string $boingUI_helpLine;

	if ( `window -ex $boingUI_window` )
	{
		showWindow $boingUI_window; 
		return;
	}
	print("Creating solver bSolver\n");
	bSolver; //create dSolver node if necessary

	$boingUI_window = `window -s 1 -t "boing - powered by Bullet" -in "boingUI"`;
	string $mainForm = `formLayout`;
	$boingUI_tabs = `tabLayout -imw 5 -imh 5 -scr 0`;
	
	formLayout -e 
		-af $boingUI_tabs "top" 0 -af $boingUI_tabs "left" 0 
		-af $boingUI_tabs "bottom" 0 -af $boingUI_tabs "right" 0 
	$mainForm;
	
	string $mainTab = boingUI_createMainTab();
	string $controlTab = boingUI_createControlTab();
	string $bakeTab = boingUI_createCaptureTab();
	string $solverTab = boingUI_createOptionsTab();
    //<rp 2014>
	string $callbackTab = boingUI_createCallBacksTab();
    //</rp 2014>
	string $helpTab = boingUI_createHelpTab();

	tabLayout -e 
		-tl $mainTab "Create" 
		-tl $controlTab "Activate" 
		-tl $bakeTab "Bake"
		-tl $solverTab "Options"
        -tl $callbackTab "Callbacks"
        -tl $helpTab "Help"
	$boingUI_tabs;
	
	setParent ..;
	string $frame = `frameLayout -lv 0`;
	$boingUI_helpLine = `textField -ed 0 -bgc 0.8 0.9 0.8 -tx "boing main window loaded"`;
	
	formLayout -e
		-an $frame  "top"
		-af $frame  "left"   0
		-af $frame  "bottom" 0
		-af $frame  "right"  0
	$mainForm;

	showWindow $boingUI_window;
	window -e -wh 500 480 $boingUI_window;
}

global proc boingUI_tools()
{
	source "boingUITools";
	boingUI_addTools();
}

global proc string boingUI_createMainTab()
{
	global float $boingUI_crackWidth = 0;
	//collision shape types: 0 = Hull, 1 = Mesh, 2 = Cylinder, 3 = Capsule, 4 = Box, 5 = Sphere, 6 = Plane, 7 = Bvh
	
	string $mainForm = `columnLayout -adj 1`;
	
		
		boingUI_createFrame("Active Rigid Bodies", "Active rigid bodies are controlled by the simulation solver and react to gravity, collisions, and fields.", 0, 0);
			rowLayout -nc 6;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "boingCreateActiveSphere.xpm" 
					-c "boingUI_createActiveSphere" -ann "Create an active sphere rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "boingCreateActiveBox.xpm" 
					-c "boingUI_createActiveBox" -ann "Create an active box rigid body";

				// iconTextButton -st "iconAndTextVertical" -l "Cylinder" -w 75 -i "boingCreateActiveCylinder.xpm"
					// -c "boingUI_createRigidBody(true, 1)" -ann "Create an active cylinder rigid body";
					
				// iconTextButton -st "iconAndTextVertical" -l "Capsule" -w 75 -i "boingCreateActiveCapsule.xpm"
					// -c "boingUI_createRigidBody(true, 1)" -ann "Create an active capsule rigid body";
					
				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "boingCreateActiveHull.xpm" 
					-c "boingUI_createActiveHull" -ann "Create active hull rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "boingCreateActiveMesh.xpm"
					-c "boingUI_createActiveMesh" -ann "Create active mesh rigid bodies from selection";
				
				iconTextButton -st "iconAndTextVertical" -l "HACD" -w 75 -i "boingCreateActiveMesh.xpm"
					-c "boingUI_createRigidBody(true, 8)" -ann "Create HACD rigid bodies from selection";
			setParent ..;
		setParent ..;

		boingUI_createFrame("Passive Rigid Bodies", "Passive rigid bodies do not react to gravity or fields, but are included in collisions.\nIf passive rigid bodies are keyed and moving, they are considered kinematic - active bodies will collide and react accordingly.", 0, 0);
			rowLayout -nc 7;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "boingCreatePassiveSphere.xpm" 
					-c "boingUI_createPassiveSphere" -ann "Create a passive sphere rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "boingCreatePassiveBox.xpm" 
					-c "boingUI_createPassiveBox" -ann "Create a passive box rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "boingCreatePassiveHull.xpm" 
					-c "boingUI_createPassiveHull" -ann "Create passive hull rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "boingCreatePassiveMesh.xpm" 
					-c "boingUI_createPassiveMesh" -ann "Create passive mesh rigid bodies from selection";

				 iconTextButton -st "iconAndTextVertical" -l "BvhMesh" -w 75 -i "boingCreatePassiveBvhMesh.xpm" 
					 -c "boingUI_createRigidBody(false, 7)" -ann "Create passive Bvh mesh rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Plane" -w 75 -i "boingCreatePassivePlane.xpm" 
					-c "boingUI_createPassivePlane" -ann "Create a passive plane rigid body";
					
				iconTextButton -st "iconAndTextVertical" -l "HACD" -w 75 -i "boingCreateActiveMesh.xpm"
					-c "boingUI_createRigidBody(false, 8)" -ann "Create passive HACD rigid bodies from selection";
					
			setParent ..;
		setParent ..;

		boingUI_createFrame("Active Rigid Body Arrays", "Active rigid body arrays are collections of like-shaped active rigid bodies.", 0, 0);
			rowLayout -nc 5;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "boingCreateActiveSphereArray.xpm"
					-c "boingUI_createRigidBodyArray(true, 5)" -ann "Create an active sphere rigid body array";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "boingCreateActiveBoxArray.xpm" 
					-c "boingUI_createRigidBodyArray(true, 4)" -ann "Create an active box rigid body array";

				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "boingCreateActiveHullArray.xpm" 
					-c "boingUI_createRigidBodyArray(true, 0)" -ann "Create an active hull rigid body array from selection";

				iconTextButton -style "iconAndTextVertical" -label "Mesh" -w 75 -i "boingCreateActiveMeshArray.xpm" 
					-c "boingUI_createRigidBodyArray(true, 1)" -ann "Create an active mesh rigid body array from selection";
			setParent ..;
		setParent ..;

		// boingUI_createFrame("Passive Rigid Body Arrays", "Passive rigid body arrays are collections of like-shaped passive rigid bodies.", 0, 0);
			// rowLayout -nc 6;
				// iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "boingCreatePassiveSphereArray.xpm" 
					// -c "boingUI_createRigidBodyArray(false, 5)" -ann "Create an passive sphere rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "boingCreatePassiveBoxArray.xpm" 
					// -c "boingUI_createRigidBodyArray(false, 4)" -ann "Create an passive box rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "boingCreatePassiveHullArray.xpm" 
					// -c "boingUI_createRigidBodyArray(false, 0)" -ann "Create an passive hull rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "boingCreatePassiveMeshArray.xpm" 
					// -c "boingUI_createRigidBodyArray(false, 1)" -ann "Create an passive mesh rigid body array from selection";

				// iconTextButton -style "iconAndTextVertical" -l "BvhMesh" -w 75 -i "boingCreatePassiveBvhMeshArray.xpm" 
					// -c "boingUI_createRigidBodyArray(false, 1)" -ann "Create an passive Bvh mesh rigid body array from selection";

				// iconTextButton -style "iconAndTextVertical" -l "Plane" -w 75 -i "boingCreatePassivePlaneArray.xpm" 
					// -c "boingUI_createRigidBodyArray(false, 6)" -ann "Create an passive plane rigid body array";
			// setParent ..;
		// setParent ..;

		boingUI_createFrame("Constraints", "Constraints inhibit the natural (unconstrained) behavior of an active rigid body.\nConstraints require at least one rigid body to be selected. Rigid bodies can be influenced by multiple constraints.", 0, 0);
			rowLayout -nc 5;
				iconTextButton -st "iconAndTextVertical" -l "Nail" -w 75 -i "boingCreateNailConstraint.xpm" 
					-c "boingUI_createNail" -ann "Create a breakable nail constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "Hinge" -w 75 -i "boingCreateHingeConstraint.xpm" 
					-c "boingUI_createHinge" -ann "Create a breakable hinge constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "Slider" -w 75  -i "boingCreateSliderConstraint.xpm" 
					-c "boingUI_createSlider" -ann "Create a breakable slider constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "6Dof" -w 75 -i "boingCreate6dofConstraint.xpm" 
					-c "boingUI_create6Dof" -ann "Create a breakable 6dof constraint";
	
				// iconTextButton -st "iconAndTextVertical" -l "ConeTwist" -w 75 -i "boingCreateConeTwistConstraint.xpm" 
					// -c "boingUI_createConeTwistConstraint" -ann "Create a cone twist constraint";
			setParent ..;
		setParent ..;
	
		boingUI_createFrame("Soft Bodies (experimental)", "Soft bodies include cloth and ropes .", 0, 0);
			rowLayout -nc 1;
				iconTextButton -st "iconAndTextVertical" -l "Soft Mesh" -w 75 -i "boingSoftMesh.xpm"
					-c "boingUI_createSoftBody()" -ann "Convert mesh to soft body";
				
			setParent ..;
		setParent ..;
	setParent ..;
	
	return $mainForm;
}

global proc string boingUI_createControlTab() 
{
	global float $boingUI_activeStartFrame = 24;
	global float $boingUI_activeEndFrame = 48;
	global int $boingUI_activateAxis = 0; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain

	string $mainForm = `columnLayout -adj 1`;

		boingUI_createFrame("Frame Range For Rigid Body Control", "Selected rigid bodies will become active during this range", 0, 0);
			rowLayout -nc 2;
				floatField -pre 3 -w 60 -v $boingUI_activeStartFrame -ann "Activation range start frame"
					-cc "$boingUI_activeStartFrame = `floatField -q -v activateStart`" activateStart;
				floatField -pre 3 -w 60 -v $boingUI_activeEndFrame -ann "Activation range end frame"
					-cc "$boingUI_activeEndFrame = `floatField -q -v activateEnd`" activateEnd;
			setParent ..;
		setParent ..;

		boingUI_createFrame("Make Rigid Bodies Active Along The X, Y, or Z Axis", "Make selected rigid bodies active along a world axis.", 0, 0);
			rowLayout -nc 6;
				iconTextButton -st "iconAndTextVertical" -l "+X Axis" -w 75 -i "boingActivateX.xpm" 
					-c "boingUI_activateAxis(0)" -ann "Activate selected rigid bodies along the +X axis";
				iconTextButton -st "iconAndTextVertical" -l "-X Axis" -w 75 -i "boingActivate-X.xpm" 
					-c "boingUI_activateAxis(1)" -ann "Activate selected rigid bodies along the -X axis";
				iconTextButton -st "iconAndTextVertical" -l "+Y Axis" -w 75 -i "boingActivateY.xpm" 
					-c "boingUI_activateAxis(2)" -ann "Activate selected rigid bodies along the +Y axis";
				iconTextButton -st "iconAndTextVertical" -l "-Y Axis" -w 75 -i "boingActivate-Y.xpm" 
					-c "boingUI_activateAxis(3)" -ann "Activate selected rigid bodies along the -Y axis";
				iconTextButton -st "iconAndTextVertical" -l "+Z Axis" -w 75 -i "boingActivateZ.xpm" 
					-c "boingUI_activateAxis(4)" -ann "Activate selected rigid bodies along the +Z axis";
				iconTextButton -st "iconAndTextVertical" -l "-Z Axis" -w 75 -i "boingActivate-Z.xpm" 
					-c "boingUI_activateAxis(5)" -ann "Activate selected rigid bodies along the -Z axis";
			setParent ..;
		setParent ..;
		
		boingUI_createFrame("Make Rigid Bodies Active In A Radial Or Chain Pattern", "Make selected rigid bodies active in a radial or chain pattern, starting with the active object in the selection.", 0, 0);
			rowLayout -nc 3;
				iconTextButton -st "iconAndTextVertical" -l "Outward" -w 75 -i "boingActivateRadial.xpm" 
					-c "boingUI_activateAxis(6)" -ann "Radially activate selected rigid bodies outwards";
				iconTextButton -st "iconAndTextVertical" -l "Inward" -w 75 -i "boingActivateRadialIn.xpm" 
					-c "boingUI_activateAxis(7)" -ann "Radially activate selected rigid bodies inwards";
				iconTextButton -st "iconAndTextVertical" -l "Daisy Chain" -w 75 -i "boingActivateChain.xpm" 
					-c "boingUI_activateAxis(8)" -ann "Chain activate selected rigid bodies";
			setParent ..;
		setParent ..;
		
		boingUI_createFrame("Configure & Modify Rigid Bodies (frame range ignored)", "Restore default active behavior, convert to passive, or set the initial state of selected rigid bodies.", 0, 0);
			rowLayout -nc 4;
				iconTextButton -st "iconAndTextVertical" -l "Make Active" -w 75 -i "boingUnactivate.xpm" 
					-c "boingUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies active (restores default behavior)";
				iconTextButton -st "iconAndTextVertical" -l "Make Passive" -w 75 -i "boingMakePassive.xpm" 
					-c "boingUI_deactivateRigidBodies(1)" -ann "Make selected rigid bodies passive";
				iconTextButton -st "iconAndTextVertical" -l "Set Initial State" -w 85 -i "boingSetInitialState.xpm" 
					-c "boingUI_setInitialState(0)" -ann "Set current state to initial state";
				iconTextButton -st "iconAndTextVertical" -l "Clear Initial State" -w 85 -i "boingClearInitialState.xpm" 
					-c "boingUI_setInitialState(1)" -ann "Restore original initial state";
			setParent ..;
		setParent ..;
	setParent ..;

	return $mainForm;
}

global proc string boingUI_createCaptureTab() 
{
	global int $boingUI_deleteEmptyNodes = 1;
	global int $boingUI_deleteBakeHistory = 1;
	global int $boingUI_deleteStaticChannels = 1;
	global int $boingUI_optimizeChannels = 1;
	global int $boingUI_captureAll = 1;
	global float $boingUI_captureStartFrame;
	global float $boingUI_captureEndFrame;
	
	float $start = `playbackOptions -q -min`;
	float $end = `playbackOptions -q -max`;

	string $mainForm = `columnLayout -adj 1`;
		boingUI_createFrame("Frame Range To Bake", "Set the starting and ending frames for baking.", 0, 0);
			rowLayout -nc 2;
				floatField -pre 3 -w 60 -v $start
					-cc "if (`floatField -q -v bakeStart` > `floatField -q -v bakeEnd`) floatField -e -v (`floatField -q -v bakeStart`) bakeEnd;$boingUI_captureStartFrame = `floatField -q -v bakeStart`" bakeStart;
				floatField -pre 3 -w 60 -v $end
					-cc "if (`floatField -q -v bakeStart` > `floatField -q -v bakeEnd`) floatField -e -v (`floatField -q -v bakeEnd`) bakeStart;$boingUI_captureEndFrame = `floatField -q -v bakeEnd`" bakeEnd;
				$boingUI_captureStartFrame = `floatField -q -v bakeStart`;
				$boingUI_captureEndFrame = `floatField -q -v bakeEnd`;
			setParent ..;
		setParent ..;
		
		boingUI_createFrame("Bake Selected Or All Rigid Bodies", "Bake keyframe data for selected or all rigid bodies in the scene.", 0, 0);
			rowLayout -nc 2;
				iconTextButton -st "iconAndTextVertical" -l "Bake Selected" -w 85 -i "boingBakeSelected.xpm" 
					-c "$boingUI_captureAll = 0; boingUI_bakeRigidBodies()" -ann "Bake Selected Rigid Bodies";
				iconTextButton -st "iconAndTextVertical" -l "Bake All" -w 75 -i "boingBakeAll.xpm" 
					-c "$boingUI_captureAll = 1; boingUI_bakeRigidBodies()" -ann "Bake All Rigid Bodies";
			setParent ..;
		setParent ..;
		
		boingUI_createFrame("Bake Options", "Enabling these options can dramatically reduce scene size and overhead.", 1, 1);
			columnLayout;
				checkBox -l "Optimize Channels (Recommended)" -v $boingUI_optimizeChannels -ann "Remove unneccassary keyframes (significantly reduces data and file size)" 
					-cc "$boingUI_optimizeChannels  = `checkBox -q -v bakeOptimize`" bakeOptimize;
				checkBox -l "Delete History (Recommended)" -v $boingUI_deleteBakeHistory -ann "Delete history on all baked objects" 
					-cc "$boingUI_deleteBakeHistory  = `checkBox -q -v bakeHistory`" bakeHistory;
				checkBox -l "Delete Empty Nodes (Recommended)" -v $boingUI_deleteEmptyNodes -ann "Remove empty and orphaned nodes" 
					-cc "$boingUI_deleteEmptyNodes  = `checkBox -q -v bakeEmpty`" bakeEmpty;
			setParent ..;
		setParent ..;
	setParent ..;

	return $mainForm;
}

global proc string boingUI_createOptionsTab()
{	
	global string $boingUI_STsolverType;
	global string $boingUI_STgravityX;
	global string $boingUI_STgravityY;
	global string $boingUI_STgravityZ;
	global string $boingUI_STenabled;
	global string $boingUI_STsplitImpulse;
	global string $boingUI_STsubsteps;
	global string $boingUI_STphysicsrate;
	global string $boingUI_STcollisionMargin;
	global string $boingUI_activateSet;
	global float $boingUI_collisionMargin;
	global float $boingUI_crackWidth;
	global int $boingUI_createActivateSet = 1;
	
	string $mainForm = `columnLayout -adj 1`;
	
		boingUI_createFrame("Solver Options", "", 1, 0);
			columnLayout;
				rowLayout -nc 2;
					columnLayout -w 220;
						text -al "left" -fn "boldLabelFont" -l "Gravity" -ann "Direction and magnitude of gravity in the simulation.";
						float $gravity[] = `getAttr bSolver.gravity`;
						rowLayout -nc 3;
							$boingUI_STgravityX = `floatField -pre 3 -w 50 -v $gravity[0]`;
							$boingUI_STgravityY = `floatField -pre 3 -w 50 -v $gravity[1]`;
							$boingUI_STgravityZ = `floatField -pre 3 -w 50 -v $gravity[2]`;
							connectControl $boingUI_STgravityX bSolver.gravityX;
							connectControl $boingUI_STgravityY bSolver.gravityY;
							connectControl $boingUI_STgravityZ bSolver.gravityZ;
						setParent ..;
					setParent ..;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Physics Framerate (Hertz)";
						int $physicsrate= `getAttr bSolver.physicsrate`; 
						$boingUI_STphysicsrate = `intField -v $physicsrate -w 50 -ann "Default is 240. Higher values \"speed up\" simulation"`;
						connectControl $boingUI_STphysicsrate bSolver.physicsrate;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout -w 220;
						text -al "left" -fn "boldLabelFont" -l "Substeps";
						int $substeps = `getAttr bSolver.substeps`; 
						$boingUI_STsubsteps = `intField -v $substeps -w 50 
							-ann "Number of times the simulation is evaluated 'between' each frame step on the timeline.\nThe default value of 1 should work for most simulations."`;
						connectControl $boingUI_STsubsteps bSolver.substeps;
					setParent ..;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Split Impulse";
						int $enabled = `getAttr bSolver.splitImpulse`;
						$boingUI_STsplitImpulse = `checkBox -l "Enabled" -v $enabled 
							-ann "Enabling Split Impulse will allow the solver to apply positional corrections when deep collision penetrations occur.\nThese corrections do not affect resulting velocities."`;
						connectControl $boingUI_STsplitImpulse bSolver.splitImpulse;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Solver State";
						int $enabled = `getAttr bSolver.enabled`;
						$boingUI_STenabled = `checkBox -l "Enabled" -v $enabled 
							-ann "Toggles the state of the solver - like an on/off switch."`;
						connectControl $boingUI_STenabled bSolver.enabled;
					setParent ..;
					columnLayout;
						//
					setParent ..;
				setParent ..;
			setParent ..;
		setParent ..;
		
		boingUI_createFrame("Tool Options", "", 1, 0);
			columnLayout;
				rowLayout -nc 2;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Collision Margin (creation only)";
						$boingUI_collisionMargin = `getAttr bSolver.collisionMargin`; 
						$boingUI_STcollisionMargin = `floatField -pre 3 -w 50 -v $boingUI_collisionMargin 
							-ann "The gap around each collision shape used for collision detection.\nThis value only effects Hull and Mesh rigid bodies during creation. Default is 0.040." 
							-cc "$boingUI_collisionMargin = `floatField -q -v $boingUI_STcollisionMargin`"`;
						connectControl $boingUI_STcollisionMargin bSolver.collisionMargin;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 1;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Disable Collisions Between Constrained Bodies (creation only)";
						int $enabled = `getAttr bSolver.disableCollisionsBetweenLinkedBodies`;
						$boingUI_disableCollisionsBetweenLinkedBodies = `checkBox -l "Enabled" -v $enabled 
							-ann "Controls the collisions of rigid bodies which share a constraint. This only effects constraints during creation."`;
						connectControl $boingUI_disableCollisionsBetweenLinkedBodies bSolver.disableCollisionsBetweenLinkedBodies;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Create Control Sets";
						$boingUI_activateSet = `checkBox -l "Enabled" -v $boingUI_createActivateSet 
							-ann "Creates quick select sets containing rigid bodies modified by activation controls." 
							-cc "$boingUI_createActivateSet = `checkBox -q -v $boingUI_activateSet`"`;
					setParent ..;
					columnLayout;
						//
					setParent ..;
				setParent ..;
				
				separator -h 10;
				button -l "Toggle Advanced Tools Tab" -c "boingUI_tools()";
			setParent ..;
		setParent ..;
		
	setParent ..;

	return $mainForm;
}

//*****************
//<rp 2014>
//*****************
global proc string boingUI_createCallBacksTab()
{
	string $mainForm = `columnLayout -adj 1`;
        boingUI_createFrame("Edit callbacks", "", 0, 0);
            rowLayout -nc 2;
                iconTextButton -st "iconAndTextVertical" -l "Create callback" -w 75 -i "boingHelp.xpm"
                -c "createNode dCallBack" -ann "Create callback";
                iconTextButton -st "iconAndTextVertical" -l "Delete callback" -w 75 -i "boingBulletWebsite.xpm"
                -c "system(\"load http://bulletphysics.org\")" -ann "Visit bulletphysics.org";
            setParent ..;
        setParent ..;
    
        //boingUI_createFrame("Callback", "", 0, 0);
            columnLayout;
    
            textScrollList -allowMultiSelection true
                -append "Only two things are infinite, the universe and human stupidity, and I'm not sure about the former."
                -uniqueTag "Albert Einstein"
                -append "Each problem that I solved became a rule, which served afterwards to solve other problems."
                -uniqueTag "Rene Descartes"
                myControlObj;

            setParent ..;
        //setParent ..;
    
	setParent ..;
    
	return $mainForm;
}
//*****************
//</rp 2014>
//*****************

global proc string boingUI_createHelpTab()
{	
	string $mainForm = `columnLayout -adj 1`;
		boingUI_createFrame("Documentation & Resources", "View the online wiki documentation or bulletphysics.org", 0, 0);
			rowLayout -nc 2;
				iconTextButton -st "iconAndTextVertical" -l "Online Help" -w 75 -i "boingHelp.xpm" 
					-c "system(\"load https://code.google.com/p/dynamica/wiki/DynamicaIntroduction\")" -ann "View Online Documentation";
				iconTextButton -st "iconAndTextVertical" -l "bulletphysics.org" -w 90 -i "boingBulletWebsite.xpm" 
					-c "system(\"load http://bulletphysics.org\")" -ann "Visit bulletphysics.org";
			setParent ..;
		setParent ..;
		
		boingUI_createFrame("Credits", "", 0, 0);
			columnLayout;
				text -al "left" -l "Original Plugin: Walt Disney Studios";
				text -al "left" -l "Original Author: Nicola Candussi";
				text -al "left" -l "Modified By: Roman Ponomarev, Erwin Coumans, Risto Puukko";
				text -al "left" -l "Tools, Features, UI & Maintenance: Michael Baker";
				text -al "left" -l "Original Baking Scripts: RBD";
                text -al "left" -l "CallBack system : Risto Puukko";
				setParent ..; //This is the additional setParent needed for MAYA 2009/2010.
			setParent ..;
		setParent ..;
		
	setParent ..;

	return $mainForm;
}

global proc string boingUI_createFrame(string $label, string $annotation, int $collapsable, int $collapsed)
{
	return `frameLayout -cll $collapsable -cl $collapsed -mh 3 -mw 6 -w 486 -h 100 -bs "etchedIn" -l $label -ann $annotation`;
}

global proc string boingUI_loadHelp()
{
	string $path = `file -query -location "boingUI.mel"`;
	$path = strip(`substitute "boingUI.mel" $path ""`);
	$path = `substitute "scripts" $path "doc"`;
	$path += "HELP.txt";

	int $fid = `fopen $path "r"`;
	string $line = `fgetline $fid`;
	string $fileData = $line;
	while (size($line) > 0)
	{
		$line =`fgetline $fid`;
		$fileData += $line;
	}
	fclose $fid;
	return $fileData;
}

global proc boingUI_print(string $out, int $mode)
{
	//modes: 0 = print, 1 = warning, 2 = error
	global string $boingUI_helpLine;
	
	if ($mode == 0)
	{
		if(`textField -ex $boingUI_helpLine`) textField -e -bgc 0.8 0.9 0.8 -tx ("boing: " + $out) $boingUI_helpLine;
		print("boing: " + $out + "\n");
	}
	else if ($mode == 1)
	{
		if(`textField -ex $boingUI_helpLine`) textField -e -bgc 1.0 1.0 0.8 -tx ("boing: " + $out) $boingUI_helpLine;
		warning("boing Warning: " + $out + "\n");
	}
	else if ($mode == 2)
	{
		if(`textField -ex $boingUI_helpLine`) textField -e -bgc 1.0 0.6 0.6 -tx ("boing: " + $out) $boingUI_helpLine;
		error("boing Error: " + $out + "\n");
	}
	refresh;
}

global proc boingUI_relinkRigidBodies()
{
	$sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "bSolver") && ($s != "bSolverMain"))
	{
		delete $s;
	}
	$sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "boingRb"))
	{
		if (`isConnected |dDebugDraw|bSolver.rigidBodies ($s+".solver")`)
		{
			disconnectAttr |dDebugDraw|bSolver.rigidBodies ($s+".solver") ;
		}
	}
	$sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "boingRb"))
	{
		// $ll = longNameOf($s);
		//print $s;	print " ----";
		if (!`isConnected |dDebugDraw|bSolver.rigidBodies ($s+".solver")`)
		{
			connectAttr -f |dDebugDraw|bSolver.rigidBodies ($s+".solver") ;
		}
	}
}

//repeatable argless commands
global proc boingUI_createActiveSphere() { boingUI_createRigidBody(true, 5); }

global proc boingUI_createActiveBox() { boingUI_createRigidBody(true, 4); } 

global proc boingUI_createActiveHull() { boingUI_createRigidBody(true, 0); }

global proc boingUI_createActiveMesh() { boingUI_createRigidBody(true, 1); }

global proc boingUI_createPassiveSphere() { boingUI_createRigidBody(false, 5); }

global proc boingUI_createPassiveBox() { boingUI_createRigidBody(false, 4); }

global proc boingUI_createPassiveHull() { boingUI_createRigidBody(false, 0); }

global proc boingUI_createPassiveMesh()  { boingUI_createRigidBody(false, 1); }

global proc boingUI_createPassiveHACD()  { boingUI_createRigidBody(false, 8); }

global proc boingUI_createPassivePlane()  { boingUI_createRigidBody(false, 6); }

global proc boingUI_createNail() { boingUI_createConstraint(0); }

global proc boingUI_createHinge() { boingUI_createConstraint(1); }

global proc boingUI_createSlider() { boingUI_createConstraint(2); }

global proc boingUI_create6Dof() { boingUI_createConstraint(3); }
//end commands



global proc boingUI_createSoftBody()
{
	
	global float $boingUI_startFrame;
	global float $boingUI_collisionMargin;
	dSolver;
	$boingUI_collisionMargin = `getAttr bSolver.collisionMargin`;
	string $meshLayer = "boingUIInputMeshes";
	string $sbLayer = "boingUISoftBodies";
	string $obSelection[] = `ls -sl`;
	string $selection[];
	string $newBodies[];
	string $sbGroup;
	string $meshGroup;
	string $margin;
	int $bodyCount = 0;
	int $makeCollisionShape = 1;
	float $collisionMargin = $boingUI_collisionMargin * 1.75; //compensate for descrepancy between Maya vertex shift and Bullet planar shift
	
	for ($o in $obSelection) mbDeleteShapeHistory($o); //clean shape history
	$selection = `ls -selection -dag -leaf -showType -type "geometry"`;
	
	
	string $softBodyNode;
	// if there is actually a selection
	if (size($selection) > 0)
	{
		boingUI_print("Creating boing soft bodies...", 0);
		refresh;
		// //create groups and layers if necessary
		// $sbGroup = `group -em -n dSoftBodies`;
		$meshGroup = `group -em -n dMeshes`;
		
		// mbHideAndLockTransform($sbGroup);
		mbHideAndLockTransform($meshGroup);
		mbCreateLayer($meshLayer, 1);
		mbCreateLayer($sbLayer, 0);
		setAttr ($sbLayer + ".shading") 0; //disable shading
	
		for ($i = 0; $i < size($selection) / 2; $i++)
		{
			string $marginShape = mbGetShape($obSelection[$i]);			
			
			if (mbIsMesh($obSelection[$i]))
			{
				
					
				if(mbIsKeyed($obSelection[$i]))
				{
					warning($obSelection[$i] + "'s transform is keyed, unable to convert to soft-body...");					
					return;
				}
								
				
				
				string $shapeTransforms[] = `listRelatives -p -f -pa $selection[$i * 2]`;
				$softBodyNode = `dSoftBody`;
				float $pos[]= `getAttr ($shapeTransforms[0] + ".translate")`;
				float $rot[]= `getAttr ($shapeTransforms[0] + ".rotate")`;
				
				// freeze transformations on selected object
				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $obSelection[$i];
				delete -ch $obSelection[$i];				
			
				// duplicate input object for output mesh.  Input object should be unchangeable so that soft body can be returned to original shape
				// also add attribute to connect input mesh to soft body
				addAttr -ln "outSoftBody" -at message $marginShape;
				connectAttr ($marginShape + ".outSoftBody") ($softBodyNode + ".inMesh");
				$dup = `duplicate $obSelection[$i]`;
				$outShape = mbGetShape($dup[0]);
				string $outTransform[] =  `listRelatives -p -f -pa $outShape`;
								
				// hide and lock the output mesh transforms;
				mbHideAndLockTransform($dup[0]);
				
				// hide input mesh 
				setAttr($obSelection[$i] + ".visibility") 0;

				// create attribute in duplicate mesh to connect soft body node to out mesh
				addAttr -ln "inSoftBody" -at message $outShape;
				connectAttr($softBodyNode + ".outMesh") ($outShape + ".inSoftBody");	
				// set collision margin.
				// is this the correct way to do it?
				setAttr($softBodyNode + ".collisionmargin") $collisionMargin;
				
				// mbHideAndLockTransform($dup[0]);
				string $softBodyTransforms[] = `listRelatives -p $softBodyNode`;
				if ($selection[$i * 2 + 1] == "mesh") {
					setAttr ($softBodyTransforms[0] + ".overrideEnabled") 1;
					setAttr ($softBodyTransforms[0] + ".overrideShading") 0;
				}			
								
				setAttr ($softBodyTransforms[0] + ".translate") -typ double3 $pos[0] $pos[1] $pos[2];
				setAttr ($softBodyNode + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
				setAttr ($softBodyTransforms[0] + ".rotate") -typ double3 $rot[0] $rot[1] $rot[2];
				setAttr ($softBodyNode + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
				
				//store original position and rotation
				addAttr -ln "originalPosition" -at double3 -k 0 $softBodyTransforms[0];
				addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $softBodyTransforms[0];
				addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $softBodyTransforms[0];
				addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $softBodyTransforms[0];
				
				addAttr -ln "originalRotation" -at double3 -k 0 $softBodyTransforms[0];
				addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $softBodyTransforms[0];
				addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $softBodyTransforms[0];
				addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $softBodyTransforms[0];
				
				// connect original mesh transform to rigid body transform
				// connectAttr ($softBodyTransforms[0] + ".translate") ($outTransform[0] + ".translate");
				// connectAttr ($softBodyTransforms[0] + ".rotate") ($outTransform[0] + ".rotate");
				// connectAttr ($softBodyTransforms[0] + ".scale") ($outTransform[0] + ".scale");
				
				$newBodies[$i] = $softBodyNode;
				//add to groups and layers
				mbAddToLayer($obSelection[$i], $meshLayer); //editDisplayLayerMembers -nr $meshLayer $shapeTransforms[0];
				// mbAddToLayer($softBodyTransforms[0], $sbLayer);
								
				parent $obSelection[$i] $meshGroup;
				// parent $softBodyTransforms[0] $sbGroup;
				// parent $softBodyNode $outShape;
				$bodyCount++;
				refresh;
			}
			else {
				boingUI_print($obSelection[$i] + " is not a Polymesh, soft body not created!", 1);
			}
		}
		//else {
				//boingUI_print($shapeTransforms[0] + " is already a soft body", 1);			
			// $makeCollisionShape = 1;
		//  }
		// if ($bodyCount) boingUI_print("Created " + $bodyCount + " rigid bodies. Find rigid bodies and source meshes in Outliner and Display Layers.", 0);
	}
	else
	{
		boingUI_print("Unable to create soft body(s), select Polymesh objects first...", 1);
	}
	currentTime $boingUI_startFrame;
	select -r $newBodies;
}







global proc boingUI_createRigidBody(int $activebody, int $collisionShapeType)
{	//collision shape types: 0 = Hull, 1 = Mesh, 2 = Cylinder, 3 = Capsule, 4 = Box, 5 = Sphere, 6 = Plane
	
	bSolver; //create dSolver node if necessary

	
	global float $boingUI_startFrame;
	global float $boingUI_collisionMargin;
	$boingUI_collisionMargin = `getAttr bSolver.collisionMargin`;
	float $mass = 1; 
	string $meshLayer = "boingUIInputMeshes";
	string $rbLayer = "boingUIRigidBodies";
	string $obSelection[] = `ls -sl`;
	string $selection[];
	string $newBodies[];
	string $rbGroup;
	string $meshGroup;
	string $margin;
	int $bodyCount = 0;
	int $makeCollisionShape = 1;
	float $collisionMargin = $boingUI_collisionMargin * 1.75; //compensate for descrepancy between Maya vertex shift and Bullet planar shift
	

	for ($o in $obSelection) mbDeleteShapeHistory($o); //clean shape history
	$selection = `ls -selection -dag -leaf -showType -type "geometry"`;
	
	if ($activebody == false) $mass = 0;
	
	
	//pick the selected object's transform only if we are creating a hull or a mesh
	if ($collisionShapeType == 0 || $collisionShapeType == 1 || $collisionShapeType == 7 || $collisionShapeType == 8) 
	{
		string $isGroup = mbSelectionIsGroup($obSelection[0]);

		string $rigidBodyNode;
		
		if (size($selection))
		{
			boingUI_print("Creating boing rigid bodies...", 0);
			refresh;
			//create groups and layers if necessary
			//$rbGroup = `group -em -n dRigidBodies`;
			//$meshGroup = `group -em -n dMeshes`;
			//mbHideAndLockTransform($rbGroup);
			//mbHideAndLockTransform($meshGroup);
			//mbCreateLayer($meshLayer, 1);
			//mbCreateLayer($rbLayer, 0);
			//setAttr ($rbLayer + ".shading") 0; //disable shading
		
			if ($isGroup)
			{
				$marginShape = $obSelection[0];
				print("it is a group!\n");
				
				///is the selection already turned into a rigid body?
				for ($i = 0; $i < size($selection) / 2; $i++)
				{
					string $connectedCollisionShapes[] = `listConnections -s 1 -t dCollisionShape $selection[$i * 2]`;
					if(size($connectedCollisionShapes) > 0) 
						$makeCollisionShape = 0;
				}
				
				if ($makeCollisionShape)
				{
					$rigidBodyNode = `boingRb`;
							
					connectAttr ($rigidBodyNode + ".outCollisionShape") ($rigidBodyNode + ".inCollisionShape");
					
					string $rigidBodyTransforms[] = `listRelatives -p $rigidBodyNode`;
					$sz = size($rigidBodyTransforms);
					//print("size($rigidBodyTransforms) = "+$sz + "\n");

					///assume at least one mesh in the group
					if ($selection[1] == "mesh") 
					{
						connectAttr ($marginShape + ".message") ($rigidBodyNode + ".inShape");
						setAttr ($rigidBodyTransforms[0] + ".overrideEnabled") 1;
						setAttr ($rigidBodyTransforms[0] + ".overrideShading") 0;		
					}
					if (mbIsKeyed($obSelection[0]))
					{
						warning($obSelection[0] + "'s transform is keyed, creating kinematic collider...");
						$mass = 0;
						mbTransferKeys($obSelection[0], $rigidBodyTransforms[0], 1);
					}

					//make each child shape a parent of the rigid body
				
				
					for ($i = 0; $i < size($selection) / 2; $i++)
					{
						string $shapeTransforms[] = `listRelatives -p -f -pa $selection[$i * 2]`;
						//print("size($shapeTransforms) = "+size($shapeTransforms) + "\n");
						//print("$shapeTransforms[0] = "+$shapeTransforms[0]+"\n");
						//parent $shapeTransforms[0] $rigidBodyNode;
					}

					setAttr ($rigidBodyNode + ".mass" ) $mass;
					setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
					
					float $pos[]= `getAttr ($obSelection[0] + ".translate")`;
					float $rot[]= `getAttr ($obSelection[0] + ".rotate")`;

					setAttr ($rigidBodyTransforms[0] + ".translate") -typ double3 $pos[0] $pos[1] $pos[2];
					setAttr ($rigidBodyNode + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
					setAttr ($rigidBodyTransforms[0] + ".rotate") -typ double3 $rot[0] $rot[1] $rot[2];
					setAttr ($rigidBodyNode + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
					
					//store original position and rotation
					addAttr -ln "originalPosition" -at double3 -k 0 $rigidBodyTransforms[0];
					addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $rigidBodyTransforms[0];
					addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $rigidBodyTransforms[0];
					addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $rigidBodyTransforms[0];
					addAttr -ln "originalRotation" -at double3 -k 0 $rigidBodyTransforms[0];
					addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $rigidBodyTransforms[0];
					addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $rigidBodyTransforms[0];
					addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $rigidBodyTransforms[0];
					
					//connect original mesh transform to rigid body transform
					connectAttr ($rigidBodyTransforms[0] + ".translate") ($obSelection[0] + ".translate");
					connectAttr ($rigidBodyTransforms[0] + ".rotate") ($obSelection[0] + ".rotate");
					connectAttr ($rigidBodyTransforms[0] + ".scale") ($obSelection[0] + ".scale");
			
								
					$newBodies[0] = $rigidBodyTransforms[0];
					//print("f ==================================================\n");
					//add to groups and layers
					mbAddToLayer($obSelection[0], $meshLayer); //editDisplayLayerMembers -nr $meshLayer $shapeTransforms[0];
					mbAddToLayer($rigidBodyTransforms[0], $rbLayer);
					parent $obSelection[0] $meshGroup;
					parent $rigidBodyTransforms[0] $rbGroup;
					$bodyCount++;
					//print("g ==================================================\n");
					refresh;
				}
				
			} else
			{
				print("it is not a group\n");

				for ($i = 0; $i < size($selection) / 2; $i++)
				{
					string $marginShape = mbGetShape($obSelection[$i]);
					string $connectedCollisionShapes[] = `listConnections -s 1 -t dCollisionShape $selection[$i * 2]`;
					if(size($connectedCollisionShapes) > 0) $makeCollisionShape = 0;
					
					string $shapeTransforms[] = `listRelatives -p -f -pa $selection[$i * 2]`;
	
					if ($makeCollisionShape)
					{
						if (mbIsMesh($obSelection[$i]))
						{
							if (!mbIsKeyed($obSelection[$i])) //process transform if not keyed
							{
								mbFreezeScale($obSelection[$i]);
								mbUnFreezeTranslation($obSelection[$i]);
								
								//process collision margin if active
								if ($activebody) 
								{
									$dup = `duplicate $obSelection[$i]`;
									$marginShape = mbGetShape($dup[0]);
									setAttr ($marginShape + ".visibility") 0;
									$margin = mbDeflate($marginShape, $collisionMargin);
									parent -s -add $marginShape $obSelection[$i];
									delete $dup;
									delete -ch $obSelection[$i];
									string $shapes[] = mbGetShapes($obSelection[$i]);
									$marginShape = $shapes[1]; //update marginShape
								}
							}
	
							$rigidBodyNode = `boingRb`;
							string $collisionShapeNode = `createNode dCollisionShape`;
							connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyNode + ".inCollisionShape");
							string $rigidBodyTransforms[] = `listRelatives -p $rigidBodyNode`;
							
							if ($selection[$i * 2 + 1] == "mesh") {
								connectAttr ($marginShape + ".message") ($collisionShapeNode + ".inShape");
								setAttr ($rigidBodyTransforms[0] + ".overrideEnabled") 1;
								setAttr ($rigidBodyTransforms[0] + ".overrideShading") 0;		
							}
							
							if (mbIsKeyed($obSelection[$i]))
							{
								warning($obSelection[$i] + "'s transform is keyed, creating kinematic collider...");
								$mass = 0;
								mbTransferKeys($obSelection[$i], $rigidBodyTransforms[0], 1);
							}
							
							setAttr ($rigidBodyNode + ".mass" ) $mass;
							setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
	
							float $pos[]= `getAttr ($shapeTransforms[0] + ".translate")`;
							float $rot[]= `getAttr ($shapeTransforms[0] + ".rotate")`;
	
							setAttr ($rigidBodyTransforms[0] + ".translate") -typ double3 $pos[0] $pos[1] $pos[2];
							setAttr ($rigidBodyNode + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
							setAttr ($rigidBodyTransforms[0] + ".rotate") -typ double3 $rot[0] $rot[1] $rot[2];
							setAttr ($rigidBodyNode + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
							
							//store original position and rotation
							addAttr -ln "originalPosition" -at double3 -k 0 $rigidBodyTransforms[0];
							addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $rigidBodyTransforms[0];
							addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $rigidBodyTransforms[0];
							addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $rigidBodyTransforms[0];
							addAttr -ln "originalRotation" -at double3 -k 0 $rigidBodyTransforms[0];
							addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $rigidBodyTransforms[0];
							addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $rigidBodyTransforms[0];
							addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $rigidBodyTransforms[0];
							
							//connect original mesh transform to rigid body transform
							connectAttr ($rigidBodyTransforms[0] + ".translate") ($shapeTransforms[0] + ".translate");
							connectAttr ($rigidBodyTransforms[0] + ".rotate") ($shapeTransforms[0] + ".rotate");
							connectAttr ($rigidBodyTransforms[0] + ".scale") ($shapeTransforms[0] + ".scale");
							
							$newBodies[$i] = $rigidBodyTransforms[0];
							
							//add to groups and layers
							mbAddToLayer($obSelection[$i], $meshLayer); //editDisplayLayerMembers -nr $meshLayer $shapeTransforms[0];
							mbAddToLayer($rigidBodyTransforms[0], $rbLayer);
							parent $obSelection[$i] $meshGroup;
							parent $rigidBodyTransforms[0] $rbGroup;
							$bodyCount++;
							
							refresh;
							//if ($activebody) mbUnflate($margin); //if active, restore shape
						}
						else
						{
							boingUI_print($obSelection[$i] + " is not a Polymesh, rigid body not created!", 1);
						}
					}
					else
					{
						boingUI_print($shapeTransforms[0] + " is already a rigid body", 1);
						//$newBodies[$i] = $shapeTransforms[0];
					}
					
					$makeCollisionShape = 1;
				}
			}
			if ($bodyCount) boingUI_print("Created " + $bodyCount + " rigid bodies. Find rigid bodies and source meshes in Outliner and Display Layers.", 0);
		}
		else
		{
			boingUI_print("Unable to create rigid body(s), select Polymesh objects first...", 1);
		}
	} 
	else //create primitive
	{
		string $rigidBodyNode = `boingRb`;
		string $collisionShapeNode = `createNode dCollisionShape`;
		connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyNode + ".inCollisionShape");
		string $rigidBodyTransforms[] = `listRelatives -parent $rigidBodyNode`;

		setAttr ($rigidBodyNode + ".mass" ) $mass;
		setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
		
		float $pos[]= `getAttr ($rigidBodyTransforms[0] + ".translate")`;
		float $rot[]= `getAttr ($rigidBodyTransforms[0] + ".rotate")`;
						
		//store original position and rotation
		addAttr -ln "originalPosition" -at double3 -k 0 $rigidBodyTransforms[0];
		addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $rigidBodyTransforms[0];
		addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $rigidBodyTransforms[0];
		addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $rigidBodyTransforms[0];
		addAttr -ln "originalRotation" -at double3 -k 0 $rigidBodyTransforms[0];
		addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $rigidBodyTransforms[0];
		addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $rigidBodyTransforms[0];
		addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $rigidBodyTransforms[0];

		$newBodies[0] = $rigidBodyTransforms[0];
		boingUI_print("Created rigid body primitive: " + $rigidBodyNode, 0);
	}

	
	currentTime $boingUI_startFrame; //force refresh
	select -r $newBodies;
}

global proc string boingUI_createConstraint(int $constraintType)
{
	//0 = Nail, 1 = Hinge, 2 = Slider, 3 = 6Dof
	string $selection[] = `ls -sl`;
	string $constraintTransforms[];
	$selection = `listRelatives -s $selection`;
	string $constraintNode;
	string $newConstraintTransf;
	
	dSolver; //create dSolver node if necessary
	
	// check selection in scene : one or two rigidBodies should be selected
	int $selSize = size($selection);
	int $selOK = (($selSize == 1) || ($selSize == 2));

	if ($selSize > 2) //more than 2 objects selected
	{
		boingUI_constrainMultiple($constraintType);
		return "";
	}
	
	for ($s in $selection) if(`nodeType $s` != "boingRb") $selOK = 0;
	
	if(!$selOK)
	{
		boingUI_print("Select one or more rigid bodies to create a constraint.", 2);
		return "";
	}
	
	//create constraint node
	switch ($constraintType)
	{
		case 0:
			$constraintNode = `dNailConstraint`;
			break;
		case 1:
			$constraintNode = `dHingeConstraint`;
			break;
		case 2:
			$constraintNode = `dSliderConstraint`;
			break;
		case 3:
			$constraintNode = `dSixdofConstraint`;
			break;
	}
	
	setAttr ($constraintNode + ".disableCollide") `getAttr bSolver.disableCollisionsBetweenLinkedBodies`;
	$constraintTransforms = `listRelatives -p $constraintNode`;
	$newConstraintTransf = $constraintTransforms[0];
	
	//connect to bodies
	if($selSize == 1)
	{
		connectAttr ($selection[0] + ".message") ($constraintNode + ".inRigidBodyA");
		string $rbTransform[] = `listRelatives -p $selection[0]`;
		float $posA[3] = `getAttr ($rbTransform[0] + ".translate")`;
		float $iWorldA[16] = `getAttr ($rbTransform[0] + ".worldMatrix")`;
		float $pivA[] = boingUI_worldToObj($posA, $iWorldA);
		setAttr ($constraintNode + ".pivotInA") -typ float3 $pivA[0] $pivA[1] $pivA[2];
		setAttr ($newConstraintTransf + ".translate") -typ float3 $posA[0] $posA[1] $posA[2];
	}
	else
	{
		connectAttr ($selection[0] + ".message") ($constraintNode + ".inRigidBodyA");
		connectAttr ($selection[1] + ".message") ($constraintNode + ".inRigidBodyB");
		string $rbTransformA[] = `listRelatives -p $selection[0]`;
		string $rbTransformB[] = `listRelatives -p $selection[1]`;
		float $posA[] = `getAttr ($rbTransformA[0] + ".translate")`;
		float $posB[] = `getAttr ($rbTransformB[2] + ".translate")`;
		float $pivW[3];
		//move constraint to midpoint between each rigid body
		$pivW[0] = mbLerpScalar($posA[0], $posB[0], 0.5);
		$pivW[1] = mbLerpScalar($posA[1], $posB[1], 0.5);
		$pivW[2] = mbLerpScalar($posA[2], $posB[2], 0.5);
		float $iWorldA[16] = `getAttr ($rbTransformA[0] + ".worldMatrix")`;
		float $iWorldB[16] = `getAttr ($rbTransformB[0] + ".worldMatrix")`;
		float $pivA[] = boingUI_worldToObj($pivW, $iWorldA);
		float $pivB[] = boingUI_worldToObj($pivW, $iWorldB);
		setAttr ($constraintNode + ".pivotInA") -typ float3 $pivA[0] $pivA[1] $pivA[2];
		setAttr ($constraintNode + ".pivotInB") -typ float3 $pivB[0] $pivB[1] $pivB[2];
		setAttr ($newConstraintTransf + ".translate") -typ float3 $pivW[0] $pivW[1] $pivW[2];
	}
	select -r $newConstraintTransf;
	return $newConstraintTransf;
}

global proc boingUI_constrainMultiple(int $constraintType)
{
	string $sel[] = `ls -sl`;
	string $selTmp[] = $sel;
	string $overlapping[];
	string $nearest[];
	string $constraints[];
	string $newConstraint;
	string $constraintLayer = "boingUIConstraints";
	string $constraintGroup;
	int $constraintCount = 0;

	//filter selection
	for ($s in $sel) if (!mbIsType($s, "boingRb")) select -d $s;
	
	$overlapping = mbGetOverlappingTransforms($sel);
	if (size($overlapping))
	{
		boingUI_print("Spatial duplicates found and ignored.", 1);
		print("boing: overlapping transforms ----------------- :\n");
		print($overlapping);
		select -d $overlapping;
	}

	$sel = `ls -sl`;
	if (size($sel) < 2)
	{
		select -r $selTmp;
		boingUI_print("No constrainable rigid bodies in selection", 2);
		return;
	}
	else
	{
		boingUI_print("Creating boing Constraints...", 0);
		//create groups and layers if necessary
		$constraintGroup = `group -em -n dConstraints`;
		mbHideAndLockTransform($constraintGroup);
		mbCreateLayer($constraintLayer, 0);
	}
	
	//collect and sort RBs
	int $last = size($sel) - 1;
	$nearest = mbDaisyChainObjects($sel, $sel[$last], 0);
	
	for ($i=0;$i<size($nearest)-1;$i++)
	{
		if ($i < (size($nearest)-1)) select -r $nearest[$i] $nearest[$i+1];

		switch ($constraintType)
		{
			case 0:
				$newConstraint = boingUI_createConstraint(0);
				break;
			case 1:
				$newConstraint = boingUI_createConstraint(1);
				break;
			case 2:
				$newConstraint = boingUI_createConstraint(2);
				break;
			case 3:
				$newConstraint = boingUI_createConstraint(3);
				break;
		}
		$constraintCount++;
		mbAddToLayer($newConstraint, $constraintLayer);
		parent $newConstraint $constraintGroup;
		$constraints[size($constraints)] = $newConstraint;
		refresh;
	}
	
	select -r $constraints;
	boingUI_print("Created " + $constraintCount + " constraints.", 0);
	clear($nearest);
	clear($sel);
	
}

global proc boingUI_createRigidBodyArray(int $activebody, int $collisionShapeType)
{
	global float $boingUI_startFrame;
	float $mass = 1;
	
	if ($activebody == false) $mass = 0;
	
	global int $boingUI_createArrayUI_size[];
	global float $boingUI_createArrayUI_offset[];

	if(`layoutDialog -title "Create Rigid Body Array" -ui "boingUI_createArrayUI"` == "OK") {    
		string $selection[] = `ls -selection -dag -leaf -showType -type "geometry"`;

		//create dSolver node if necessary
		dSolver;

		string $rigidBodyArrayNode = `dRigidBodyArray`;
		string $collisionShapeNode = `createNode dCollisionShape`;
		connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyArrayNode + ".inCollisionShape");
		string $rigidBodyTransforms[] = `listRelatives -parent $rigidBodyArrayNode`;
		
		if(size($selection) != 0) {
			string $shapeTransforms[] = `listRelatives -parent $selection[0]`;
			if($selection[1] == "mesh") {
				connectAttr ($selection[0] + ".message") ($collisionShapeNode + ".inShape");
				hide $shapeTransforms[0];
			}
		}
		
		setAttr ($rigidBodyArrayNode + ".mass" ) $mass;
		setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
		
		select -r $rigidBodyTransforms[0];

		int $size[]= $boingUI_createArrayUI_size;
		float $off[]= $boingUI_createArrayUI_offset;
		float $x0[];
		$x0[0] = -0.5 * $size[0] * $off[0];
		$x0[1] = -0.5 * $size[1] * $off[1];
		$x0[2] = -0.5 * $size[2] * $off[2];
		setAttr ($rigidBodyArrayNode + ".numBodies") ($size[0] * $size[1] * $size[2]);
		for ($i = 0; $i < $size[0]; $i++) {
			for ($j = 0; $j < $size[1]; $j++) {
				for ($k = 0; $k < $size[2]; $k++) {
					setAttr ($rigidBodyArrayNode + ".initialPosition[" + string($i + $size[0] * $j + $size[0] * $size[1] * $k) + "]") ($x0[0] + $i * $off[0]) ($x0[1] + $j * $off[1]) ($x0[2] + $k * $off[2]);
				}
			}
		}  
		currentTime $boingUI_startFrame; //force refresh		
	}
}

global proc boingUI_createArrayUIdismissCB(string $button)
{
	global string $boingUI_createArrayUI_sizeCT;
	global string $boingUI_createArrayUI_offsetCT;

	global int $boingUI_createArrayUI_size[];
	global float $boingUI_createArrayUI_offset[];

	$boingUI_createArrayUI_size = `intFieldGrp -query -value $boingUI_createArrayUI_sizeCT`; 
	$boingUI_createArrayUI_offset = `floatFieldGrp -query -value $boingUI_createArrayUI_offsetCT`; 
	layoutDialog -dismiss $button;
}

global proc boingUI_createArrayUI()
{
	global string $boingUI_createArrayUI_sizeCT;
	global string $boingUI_createArrayUI_offsetCT;

	// Get the dialog's formLayout.
	string $form = `setParent -q`;

	// layoutDialog's are not resizable, so hard code a size here,
	// to make sure all UI elements are visible.
	formLayout -e -width 400 $form;

	string $b1 = `button -l "OK"    -c "boingUI_createArrayUIdismissCB(\"OK\")"`;
	string $b2 = `button -l "Cancel"-c "boingUI_createArrayUIdismissCB(\"Cancel\")"`;

	$boingUI_createArrayUI_sizeCT = `intFieldGrp -columnAlign 1 "left" -adj 1 -numberOfFields 3 -label "Array Size" -v1 3 -v2 3 -v3 3`;
	$boingUI_createArrayUI_offsetCT = `floatFieldGrp -columnAlign 1 "left" -adj 1 -numberOfFields 3 -label "Array Offset" -v1 2.0 -v2 2.0 -v3 2.0`;

	formLayout -edit
	-attachForm            $boingUI_createArrayUI_sizeCT   "top"    5
	-attachForm            $boingUI_createArrayUI_sizeCT   "left"   5
	-attachNone            $boingUI_createArrayUI_sizeCT   "bottom"
	-attachForm            $boingUI_createArrayUI_sizeCT   "right"  5 

	-attachControl         $boingUI_createArrayUI_offsetCT  "top"   5 $boingUI_createArrayUI_sizeCT
	-attachForm            $boingUI_createArrayUI_offsetCT  "left"   5
	-attachNone            $boingUI_createArrayUI_offsetCT  "bottom"
	-attachForm            $boingUI_createArrayUI_offsetCT   "right"  5 

	-attachControl         $b1  "top"   5 $boingUI_createArrayUI_offsetCT
	-attachForm            $b1  "left"   5
	-attachNone            $b1  "bottom"
	-attachPosition        $b1  "right"  5 33

	-attachControl         $b2  "top"    5 $boingUI_createArrayUI_offsetCT
	-attachPosition        $b2  "left"   5 33
	-attachNone            $b2  "bottom"
	-attachPosition        $b2  "right"  5 66

	$form;
}

global proc float[] boingUI_worldToObj(float $pointW[], float $objToWorldMatrix[])
{
	float $result[];
	$result[0] = 0.0;
	$result[1] = 0.0;
	$result[2] = 0.0;
	float $offs[];
	if ( size($pointW) != 3 || size($objToWorldMatrix) != 16 )
	{
		warning("Point must be an array of 3 doubles and matrix must be an array of 16 doubles.");
		return $result;
	}
	for ($i = 0; $i < 3; $i++)
	{
		$offs[$i] = $pointW[$i] - $objToWorldMatrix[12 + $i];
	}
	for ($i = 0; $i < 3; $i++)
	{
		for ($j = 0; $j < 3; $j++)
		{
			$result[$i] += $objToWorldMatrix[$i * 4 + $j] * $offs[$j];
		}
	}
	return $result;
}

global proc boingUI_activateAxis(int $axis)
{
	global int $boingUI_activateAxis; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain
	$boingUI_activateAxis = $axis; 
	boingUI_activateRigidBodies();
}

global proc boingUI_activateRigidBodies() 
{
	global float $boingUI_activeStartFrame;
	global float $boingUI_activeEndFrame;
	global int $boingUI_activateAxis; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain
	global int $boingUI_createActivateSet;

	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	string $sorted[];
	float $attrs[];
	string $axis;
	int $reverseAxis = 0;
	int $selChunks;
	string $refr[];
	int $incr = 0;
	int $i;

	//filter selection
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "boingRb")) select -add $s; //if boingRb
	$sel = `ls -sl`;
	for ($s in $sel) if (mbIsKeyed($s)) select -d $s; //if keyed
	$sel = `ls -sl`;
	$selChunks = (int)size($sel)/10;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		boingUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	//we are go!
	boingUI_print("Activating " + size($sel) + " rigid bodies...", 0);
	refresh;
	if ($boingUI_createActivateSet) sets -n "ActivatedRigidBodies";

	switch ($boingUI_activateAxis) 
	{
		case 0: $axis = "tx"; break;
		case 1: $axis = "tx"; $reverseAxis = 1; break;
		case 2: $axis = "ty"; break;
		case 3: $axis = "ty"; $reverseAxis = 1; break;
		case 4: $axis = "tz"; break;
		case 5: $axis = "tz"; $reverseAxis = 1; break;
		case 7: $reverseAxis = 1; break;
		case 8: break;
	}
	
	if ($boingUI_activateAxis < 6) //linear axis
	{
		$sorted = mbSortObjectsByAttr($sel, $axis, 0);
		for ($o in $sorted) $attrs[size($attrs)] = `getAttr ($o + "." + $axis)`;
	}
	else if ($boingUI_activateAxis == 6 || $boingUI_activateAxis == 7)//radial axis
	{
		$sorted = mbProximitySort($sel);
		for ($o in $sorted) $attrs[size($attrs)] = mbDistanceBetweenNodes($sorted[0], $o);
	}
	else if ($boingUI_activateAxis == 8) //daisy chain
	{
		boingUI_print("Computing chain sequence...", 0);
		int $last = size($sel) - 1;
		$sorted = mbDaisyChainObjects($sel, $sel[$last], 0);
		for ($i=0;$i<size($sorted);$i++) $attrs[size($attrs)] = $i; //mbDistanceBetweenNodes($sorted[$i], $sorted[$i+1]);
	}

	if ($reverseAxis) $sorted = mbReverseStringArray($sorted);
	$attrs = mbScaleArray($attrs, $boingUI_activeStartFrame, $boingUI_activeEndFrame, 1);

	
	for ($i=0;$i<size($sorted);$i++) 
	{
		float $mass = `getAttr (mbGetShape($sorted[$i]) + ".mass")`;
		if ($mass == 0) $mass = 1;
		cutKey -at "mass" -cl $sorted[$i];
		setKeyframe -at "mass" -t 1 -v 1 $sorted[$i];
		setKeyframe -at "mass" -t 2 -v 0 $sorted[$i];
		setKeyframe -at "mass" -t $attrs[$i] -v $mass $sorted[$i];
		keyTangent -itt "flat" -ott "step" $sorted[$i];
		
		//visual feedback in viewport
		$refr[size($refr)] = $sorted[$i];
		$incr++;
		if ($incr == $selChunks)
		{
			select -r $refr; 
			refresh;
			$incr = 0;
			clear($refr);
			select -cl;
			refresh;
		}
	}

	boingUI_print(size($sel) + " rigid bodies activated. Frame range: "
		+ $boingUI_activeStartFrame + " - " + $boingUI_activeEndFrame, 0);
}

global proc boingUI_deactivateRigidBodies(int $toPassive)
{
	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "boingRb")) select -add $s; //if boingRB
	$sel = `ls -sl`;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		boingUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	boingUI_print("Removing activation from " + size($sel) + " rigid bodies...", 0);
	refresh;
	
	for ($s in $sel)
	{
		cutKey -at "mass" -cl $s;
		setAttr ($s + ".mass") 1;
		if ($toPassive) setAttr ($s + ".mass") 0;
	}
	
	if ($toPassive)
	{
		boingUI_print(size($sel) + " rigid bodies made passive (mass = 0).", 0);
	}
	else
	{
		boingUI_print(size($sel) + " rigid bodies made active (mass > 0).", 0);
	}
}

global proc boingUI_setInitialState(int $reset)
{	
	global float $boingUI_startFrame;
	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	string $constraints[];
	
	//filter selection
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "boingRb")) select -add $s; //if boingRB
	$sel = `ls -sl`;
	for ($s in $sel) if (mbIsKeyed($s)) select -d $s; //if keyed
	$sel = `ls -sl`;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		boingUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	//we are go!
	boingUI_print("Setting initial state for " + size($sel) + " rigid bodies...", 0);
	refresh;

	for ($s in $sel)
	{
		if ($reset)
		{
			$posX = `getAttr ($s + ".originalPositionX")`;
			$posY = `getAttr ($s + ".originalPositionY")`;
			$posZ = `getAttr ($s + ".originalPositionZ")`;
			$rotX = `getAttr ($s + ".originalRotationX")`;
			$rotY = `getAttr ($s + ".originalRotationY")`;
			$rotZ = `getAttr ($s + ".originalRotationZ")`;
			setAttr ($s + ".initialPosition") -typ double3 $posX $posY $posZ;
			setAttr ($s + ".initialRotation") -typ double3 $rotX $rotY $rotZ;
		}
		else
		{
			float $pos[] = `xform -q -ws -t $s`;
			float $rot[] = `xform -q -ws -ro $s`;
			setAttr ($s + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
			setAttr ($s + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
		}
		
		//collect connected constraints
		string $conn[];
		$rels = `listRelatives $s`;
		if (size($rels)) $conn = `listConnections $rels`;
		for($c in $conn)
		{
			$shape = mbGetShape($c);
			if (size($shape))
			{					
				if (`nodeType $shape` == "dNailConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dHingeConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dSliderConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dSixdofConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
			}
		}
	}

	currentTime $boingUI_startFrame;
	boingUI_updateConstraints($constraints);
}

global proc boingUI_updateConstraints(string $constraints[])
{
	global float $boingUI_startFrame;
	string $sel[];
	
	for ($c in $constraints)
	{
		string $type = mbGetType(mbGetShape($c));
		if ($type == "dNailConstraint") $sel[size($sel)] = $c;
		if ($type == "dHingeConstraint") $sel[size($sel)] = $c;
		if ($type == "dSliderConstraint") $sel[size($sel)] = $c;
		if ($type == "dSixdofConstraint") $sel[size($sel)] = $c;
	}
	
	for ($s in $sel)
	{
		$shape = mbGetShape($s);
		$selection = `listConnections $shape`;
		
		if (size($selection) == 1)
		{
			float $posA[] = `xform -q -ws -t $selection[0]`;
			setAttr ($s + ".translate") -typ float3 $posA[0] $posA[1] $posA[2];
		}
		if (size($selection) == 2)
		{
			float $posA[] = `xform -q -ws -t $selection[0]`;
			float $posB[] = `xform -q -ws -t $selection[1]`;
			float $pivW[3];
			$pivW[0] = mbLerpScalar($posA[0], $posB[0], 0.5);
			$pivW[1] = mbLerpScalar($posA[1], $posB[1], 0.5);
			$pivW[2] = mbLerpScalar($posA[2], $posB[2], 0.5);
			setAttr ($s + ".translate") -typ float3 $pivW[0] $pivW[1] $pivW[2];
		}
	}
}

global proc boingUI_bakeRigidBodies()
{
	global int $boingUI_deleteEmptyNodes;
	global int $boingUI_deleteBakeHistory;
	global int $boingUI_optimizeChannels;
	global int $boingUI_captureAll;
	global float $boingUI_captureStartFrame;
	global float $boingUI_captureEndFrame;
	
	string $dBakeLayer = "boingUIBaked";
	string $bakeGroup;
	string $sel[] = `ls -sl`;
	string $toBake[];
	string $preKeyed[];
	string $baked[];
	float $progress;
	int $go = 0;
	
	select -cl;
	
	//select all rigid bodies
	if ($boingUI_captureAll) $sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "boingRb")) mbAddToSelection($s);
	$sel = `ls -sl`;
	
	//remove prekeyed objects from selection
	for ($s in $sel)
	{
		if (mbIsKeyed($s))
		{
			$preKeyed[size($preKeyed)] = $s;
			select -d $s;
		}
		if (!mbIsType($s, "boingRb"))
		{
			select -d $s;
		}
	}
	
	$sel = `ls -sl`;
	if (!size($sel)) 
	{
		select -r $sel;
		boingUI_print("No rigid bodies to bake.", 2);
		return;
	}
	
	//confirm
	$confirm = `confirmDialog -t "boing: Bake Rigid Bodies" -m "Bake boing Simulation?\nThis action is not undoable."
		-b "Yes" -b "No" -db "Yes" -cb "No" -ds "No"`;
	if ($confirm == "No") 
	{
		select -r $sel;
		boingUI_print("Bake cancelled by user.", 1);
		return;
	}
	
	//we are go
	boingUI_print("Baking " + size($sel) + "rigid bodies...", 0);
	mbCreateLayer($dBakeLayer, 0);
	if ($boingUI_deleteBakeHistory) delete -ch;
	undoInfo -state off;
	select -cl;
	
	//find connected transforms, modify selection
	for ($s in $sel)
	{
		$connectedTransforms = mbGetConnectedTransforms($s);
		if (size($connectedTransforms))
		{
			if (mbIsMesh($connectedTransforms[0])) 
			{
				$toBake[size($toBake)] = $connectedTransforms[0];
				mbAddToLayer($connectedTransforms[0], $dBakeLayer);
			}
		}
		else 
		{
			$toBake[size($toBake)] = $s;
			mbAddToLayer($s, $dBakeLayer);
		}
	}
	
	select -r $toBake;
	
	//bake!
	boingUI_print("boingUI: Baking simulation...", 0);
	$baked = `ls -sl`;
	cycleCheck -e off;
	bakeResults 
		-simulation 1 
		-t ((string)$boingUI_captureStartFrame + ":" + (string)$boingUI_captureEndFrame) 
		-sampleBy 1 
		-disableImplicitControl 1 
		-preserveOutsideKeys 1 
		-sparseAnimCurveBake 0
		-controlPoints 0
		-shape 0
		-at "tx" 
		-at "ty" 
		-at "tz" 
		-at "rx" 
		-at "ry" 
		-at "rz";
	
	select -cl;
	
	//delete orphans
	boingUI_print("Removing orphaned rigid bodies and constraints...", 0);
	for ($s in $sel) 
	{
		select -add $s;
		string $conn[];
		$rels = `listRelatives $s`;
		if (size($rels)) $conn = `listConnections $rels`;
		for($c in $conn)
		{
			$shape = mbGetShape($c);
			if (size($shape))
			{					
				if (`nodeType $shape` == "dNailConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dHingeConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dSliderConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dSixdofConstraint" && `objExists $c` == true) select -add $c;
			}
		}

		//filter and process primitives
		if (mbIsType($s, "boingRb"))
		{
			$connectedTransforms = mbGetConnectedTransforms($s);
			string $connectedCollisionShape = mbGetConnectedByType(mbGetShape($s), "dCollisionShape");
			if (!size($connectedTransforms))
			{
				select -d $s;
				setAttr ($s + ".mass") 0;
			}
		}
		
		dgeval `mbGetShape($s)`;
	}

	$sel = `ls -sl`;
	if (size($sel))
	{
		boingUI_print(size($sel) + " orphans found, deleting...", 0);
		delete;
	}
	
	if ($boingUI_optimizeChannels) 
	{
		boingUI_print("Optimizing channels...", 0);
		//delete -staticChannels -uac 0 -hi none -cp 0 -s 0; //brute force - kills all static channels in scene
		for ($b in $baked)
		{
			if (size($preKeyed)) 
			{
				for ($p in $preKeyed)
				{
					if ($b != $p)
					{
						delete -staticChannels -uac 0 -hi none -cp 0 -s 0 $b;
						break;
					}
					else
					{
						break;
					}
				}
			} 
			else 
			{
				delete -staticChannels -uac 0 -hi none -cp 0 -s 0 $b;
			}
			
			filterCurve -f simplify -timeTolerance 0 -tol 0.0001 {$b + ".rotateY", $b+ ".rotateX", $b + ".translateZ", $b + ".translateY", $b + ".translateX", $b + ".rotateZ"};
		}
	}

	if ($boingUI_deleteEmptyNodes)
	{
		boingUI_print("Removing empty nodes...", 0);
		mbDeleteEmptyNodes();
	}

	if ($boingUI_deleteBakeHistory)
	{
		boingUI_print("Removing history...", 0);
		delete -all -ch;
		
		for ($b in $baked) mbDeleteShapeHistory($b); //clean shape history
	}
	
	undoInfo -state on;
	select -r $baked;
	$bakeGroup = `group -em -n dBaked`;
	for ($b in $baked) parent $b $bakeGroup; //move to baked group
	boingUI_print("Baked " + size($baked) + " rigid bodies on frames " + $boingUI_captureStartFrame + " - " + $boingUI_captureEndFrame, 0);
}

//callbacks
global proc int bulletExportOptions( string $parent, string $action, string $settings, string $callback ) 
{
	return 1;
}

//script jobs
global proc boingUI_syncSolver()
{
	if (`objExists bSolver`)
	{
		global float $boingUI_startFrame;
		float $startFrame = `playbackOptions -q -min`;
		setAttr "bSolver.startTime" $startFrame;
		$boingUI_startFrame = $startFrame;
		boingUI_print("Updated solver Start Time to: " + (string)$boingUI_startFrame, 0);
	}
}

global proc boingUI_onSceneOpen()
{
	global int $boingUI_syncSolverJob = -1;
	if (!`scriptJob -ex $boingUI_syncSolverJob`)
	{
		$boingUI_syncSolverJob = `scriptJob -kws -e "playbackRangeChanged" boingUI_syncSolver`;
	}
}

global proc boingUI_onPluginLoad()
{
	global int $boingUI_sceneOpenJob = -1;
	if (!`scriptJob -ex $boingUI_sceneOpenJob`)
	{
		$boingUI_sceneOpenJob = `scriptJob -e "SceneOpened" boingUI_onSceneOpen`;
	}
	
	boingUI_onSceneOpen();
}

