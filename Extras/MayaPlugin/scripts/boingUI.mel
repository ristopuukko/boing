/*
Bullet Continuous Collision Detection and Physics Library Maya Plugin
Copyright (c) 2008 Walt Disney Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising
from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must
not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Nicola Candussi <nicola@fluidinteractive.com>

Modified by Roman Ponomarev <rponom@gmail.com>
01/22/2010 : Constraints reworked

Modified by Michael Baker <michael@mBakr.com>
*/
//init
global proc boingUI_initialize() //this proc is called from the plugin
{	
	print("Loading boing plugin...\n");
	
	global float $boingUI_startFrame;
	global float $boingUI_captureStartFrame;
	global float $boingUI_captureEndFrame;
	
	source "mbUtils";

	//add boing menu to the main window
	global string $gMainWindow;
	string $boingMainMenu = `menu -l "boing" -to 1 -p $gMainWindow`;
	menuItem -l "boing Window" -ann "Open the main boing window" -c "boingUI_createWindow()" -fi "boingWindow.xpm" $boingMainMenu;
	menuItem -d 1 $boingMainMenu;
	menuItem -l "Help" -ann "View the wiki online" -c "system(\"load http://code.google.com/p/boingUI/wiki/boingUIIntroduction\")" $boingMainMenu;

	//initial settings
	$boingUI_startFrame = `playbackOptions -q -min`; //init start frame
	boingUI_onPluginLoad(); //init script jobs
	playbackOptions -e -playbackSpeed 0 -maxPlaybackSpeed 1; //set playback options
	$boingUI_captureStartFrame = `playbackOptions -q -min`;
	$boingUI_captureEndFrame = `playbackOptions -q -max`;
	boingUI_createShelf();
	
	print("Loading boing plugin...complete.\n");
}
    
//shelf
global proc boingUI_createShelf()
{
	global string $gShelfTopLevel;
	string $shelf = "boing";
	string $boingShelf;
	
	if ( `shelfLayout -ex $shelf` )
	{
		$boingShelf = $shelf;
		string $shelfButtons[] = `shelfLayout -q -ca $shelf`;
		for ( $b in $shelfButtons ) deleteUI $b;
	} 
	else 
	{
		// Create the shelf under the global shelf parent.
		$boingShelf = `shelfLayout -p $gShelfTopLevel $shelf`;
	}
	
	shelfButton -i "boingWindow.xpm" -c "boingUI_createWindow" -ann "Open Main boing Window" -p $boingShelf;
	shelfButton -i "boingRelink.xpm" -c "boingUI_relinkRigidBodies" -ann "Relink bodies to solver after copy and paste" -p $boingShelf;
	
	shelfButton -i "boingCreateActiveSphere.xpm" 
		-c "boingUI_createActiveSphere" -ann "Create an active sphere rigid body" -p $boingShelf;
	shelfButton -i "boingCreateActiveBox.xpm" 
		-c "boingUI_createActiveBox" -ann "Create an active box rigid body" -p $boingShelf;
	// shelfButton -i "boingCreateActiveCylinder.xpm" 
		// -c "boingUI_createRigidBody(true, 5)" -ann "Create an active cylinder rigid body" -p $boingShelf;
	// shelfButton -i "boingCreateActiveCapsule.xpm" 
		// -c "boingUI_createRigidBody(true, 4)" -ann "Create an active capsule rigid body" -p $boingShelf;
	shelfButton -i "boingCreateActiveHull.xpm" 
		-c "boingUI_createActiveHull" -ann "Create active hull rigid bodies" -p $boingShelf;
	shelfButton -i "boingCreateActiveMesh.xpm"
		-c "boingUI_createActiveMesh" -ann "Create active mesh rigid bodies" -p $boingShelf;
	shelfButton -i "boingCreateActiveMesh.xpm"
		-c "boingUI_createRigidBody(true, 8)" -ann "Create HACD rigid bodies" -p $boingShelf;
		
	shelfButton -i "boingCreatePassiveSphere.xpm" 
		-c "boingUI_createPassiveSphere" -ann "Create passive sphere rigid body" -p $boingShelf;
	shelfButton -i "boingCreatePassiveBox.xpm" 
		-c "boingUI_createPassiveBox" -ann "Create passive box rigid body" -p $boingShelf;
	shelfButton -i "boingCreatePassiveHull.xpm" 
		-c "boingUI_createPassiveHull" -ann "Create passive hull rigid bodies" -p $boingShelf;
	shelfButton -i "boingCreatePassiveMesh.xpm" 
		-c "boingUI_createPassiveMesh" -ann "Create passive mesh rigid bodies" -p $boingShelf;
	shelfButton -i "boingCreatePassivePlane.xpm" 
		-c "boingUI_createPassivePlane" -ann "Create passive plane rigid body" -p $boingShelf;

	shelfButton -i "boingCreateActiveMesh.xpm"
		-c "boingUI_createPassiveHACD(true, 8)" -ann "Create passive HACD rigid body" -p $boingShelf;
	
	
	
	shelfButton -i "boingCreateNailConstraint.xpm" 
		-c "boingUI_createNail" -ann "Create a breakable nail constraint" -p $boingShelf;
	shelfButton -i "boingCreateHingeConstraint.xpm" 
		-c "boingUI_createHinge" -ann "Create a breakable hinge constraint" -p $boingShelf;
	shelfButton -i "boingCreateSliderConstraint.xpm" 
		-c "boingUI_createSlider" -ann "Create a breakable slider constraint" -p $boingShelf;
	shelfButton -i "boingCreate6dofConstraint.xpm" 
		-c "boingUI_create6Dof" -ann "Create a breakable 6dof constraint" -p $boingShelf;
		
	shelfButton -i "boingSoftMesh.xpm"
		-c "boingUI_createSoftBody()" -ann "Create a softbody" -p $boingShelf;
		
	// shelfButton -i "boingCreateConetwistConstraint.xpm" 
		// -c "boingUI_createConstraint(3)" -ann "Create a breakable cone twist constraint" -p $boingShelf;
		
	// shelfButton -i "boingActivateX.xpm" 
		// -c "boingUI_activateAxis(0)" -ann "Activate selected rigid bodies along the +X axis" -p $boingShelf;
	// shelfButton -i "boingActivate-X.xpm" 
		// -c "boingUI_activateAxis(1)" -ann "Activate selected rigid bodies along the -X axis" -p $boingShelf;
	// shelfButton -i "boingActivateY.xpm" 
		// -c "boingUI_activateAxis(2)" -ann "Activate selected rigid bodies along the +Y axis" -p $boingShelf;
	// shelfButton -i "boingActivate-Y.xpm" 
		// -c "boingUI_activateAxis(3)" -ann "Activate selected rigid bodies along the -Y axis" -p $boingShelf;
	// shelfButton -i "boingActivateZ.xpm" 
		// -c "boingUI_activateAxis(4)" -ann "Activate selected rigid bodies along the +Z axis" -p $boingShelf;
	// shelfButton -i "boingActivate-Z.xpm" 
		// -c "boingUI_activateAxis(5)" -ann "Activate selected rigid bodies along the -Z axis" -p $boingShelf;
		
	// shelfButton -i "boingActivateRadial.xpm" 
		// -c "boingUI_activateAxis(6)" -ann "Activate selected rigid bodies outwards" -p $boingShelf;
	// shelfButton -i "boingActivateRadialIn.xpm" 
		// -c "boingUI_activateAxis(7)" -ann "Activate selected rigid bodies inwards" -p $boingShelf;
	// shelfButton -i "boingActivateChain.xpm" 
		// -c "boingUI_activateAxis(8)" -ann "Chain activate selected rigid bodies" -p $boingShelf;
		
	// shelfButton -i "boingUnactivate.xpm" 
		// -c "boingUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies active (restores default behavior)" -p $boingShelf;
	// shelfButton -i "boingMakePassive.xpm" 
		// -c "boingUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies passive" -p $boingShelf;
	// shelfButton -i "boingSetInitialState.xpm" 
		// -c "boingUI_setInitialState(0)" -ann "Set current state to initial state" -p $boingShelf;
	// shelfButton -i "boingClearInitialState.xpm" 
		// -c "boingUI_setInitialState(1)" -ann "Restore original initial state" -p $boingShelf;
		
	// shelfButton -i "boingBakeSelected.xpm" 
		// -c "$boingUI_captureAll = 0; boingUI_bakeRigidBodies()" -ann "Bake Selected Rigid Bodies" -p $boingShelf;
	// shelfButton -i "boingBakeAll.xpm" 
		// -c "$boingUI_captureAll = 1; boingUI_bakeRigidBodies()" -ann "Bake All Rigid Bodies" -p $boingShelf;
	
	shelfButton -i "boingUIHelp.xpm" -c "system(\"load http://code.google.com/p/boingUI/wiki/boingUIIntroduction\")" 
		-ann "View Online Documentation" -p $boingUIShelf;
	// shelfButton -i "boingUITools.xpm" -c "boingUIUI_tools()" -ann "Open Main boingUI Window" -p $boingUIShelf;
}

//UI
global proc boingUIUI_createWindow()
{
	global string $boingUIUI_window;
	global string $boingUIUI_tabs;
	global string $boingUIUI_helpLine;

	if ( `window -ex $boingUIUI_window` )
	{
		showWindow $boingUIUI_window; 
		return;
	}
	
	dSolver; //create dSolver node if necessary

	$boingUIUI_window = `window -s 1 -t "boing - powered by Bullet" -in "boingUI"`;
	string $mainForm = `formLayout`;
	$boingUIUI_tabs = `tabLayout -imw 5 -imh 5 -scr 0`;
	
	formLayout -e 
		-af $boingUIUI_tabs "top" 0 -af $boingUIUI_tabs "left" 0 
		-af $boingUIUI_tabs "bottom" 0 -af $boingUIUI_tabs "right" 0 
	$mainForm;
	
	string $mainTab = boingUIUI_createMainTab();
	string $controlTab = boingUIUI_createControlTab();
	string $bakeTab = boingUIUI_createCaptureTab();
	string $solverTab = boingUIUI_createOptionsTab();
    //<rp 2014>
	string $callbackTab = boingUIUI_createCallBacksTab();
    //</rp 2014>
	string $helpTab = boingUIUI_createHelpTab();

	tabLayout -e 
		-tl $mainTab "Create" 
		-tl $controlTab "Activate" 
		-tl $bakeTab "Bake"
		-tl $solverTab "Options"
        -tl $callbackTab "Callbacks"
        -tl $helpTab "Help"
	$boingUIUI_tabs;
	
	setParent ..;
	string $frame = `frameLayout -lv 0`;
	$boingUIUI_helpLine = `textField -ed 0 -bgc 0.8 0.9 0.8 -tx "boing main window loaded"`;
	
	formLayout -e
		-an $frame  "top"
		-af $frame  "left"   0
		-af $frame  "bottom" 0
		-af $frame  "right"  0
	$mainForm;

	showWindow $boingUIUI_window;
	window -e -wh 500 480 $boingUIUI_window;
}

global proc boingUIUI_tools()
{
	source "boingUIUITools";
	boingUIUI_addTools();
}

global proc string boingUIUI_createMainTab()
{
	global float $boingUIUI_crackWidth = 0;
	//collision shape types: 0 = Hull, 1 = Mesh, 2 = Cylinder, 3 = Capsule, 4 = Box, 5 = Sphere, 6 = Plane, 7 = Bvh
	
	string $mainForm = `columnLayout -adj 1`;
	
		
		boingUIUI_createFrame("Active Rigid Bodies", "Active rigid bodies are controlled by the simulation solver and react to gravity, collisions, and fields.", 0, 0);
			rowLayout -nc 6;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "boingUICreateActiveSphere.xpm" 
					-c "boingUIUI_createActiveSphere" -ann "Create an active sphere rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "boingUICreateActiveBox.xpm" 
					-c "boingUIUI_createActiveBox" -ann "Create an active box rigid body";

				// iconTextButton -st "iconAndTextVertical" -l "Cylinder" -w 75 -i "boingUICreateActiveCylinder.xpm"
					// -c "boingUIUI_createRigidBody(true, 1)" -ann "Create an active cylinder rigid body";
					
				// iconTextButton -st "iconAndTextVertical" -l "Capsule" -w 75 -i "boingUICreateActiveCapsule.xpm"
					// -c "boingUIUI_createRigidBody(true, 1)" -ann "Create an active capsule rigid body";
					
				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "boingUICreateActiveHull.xpm" 
					-c "boingUIUI_createActiveHull" -ann "Create active hull rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "boingUICreateActiveMesh.xpm"
					-c "boingUIUI_createActiveMesh" -ann "Create active mesh rigid bodies from selection";
				
				iconTextButton -st "iconAndTextVertical" -l "HACD" -w 75 -i "boingUICreateActiveMesh.xpm"
					-c "boingUIUI_createRigidBody(true, 8)" -ann "Create HACD rigid bodies from selection";
			setParent ..;
		setParent ..;

		boingUIUI_createFrame("Passive Rigid Bodies", "Passive rigid bodies do not react to gravity or fields, but are included in collisions.\nIf passive rigid bodies are keyed and moving, they are considered kinematic - active bodies will collide and react accordingly.", 0, 0);
			rowLayout -nc 7;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "boingUICreatePassiveSphere.xpm" 
					-c "boingUIUI_createPassiveSphere" -ann "Create a passive sphere rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "boingUICreatePassiveBox.xpm" 
					-c "boingUIUI_createPassiveBox" -ann "Create a passive box rigid body";

				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "boingUICreatePassiveHull.xpm" 
					-c "boingUIUI_createPassiveHull" -ann "Create passive hull rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "boingUICreatePassiveMesh.xpm" 
					-c "boingUIUI_createPassiveMesh" -ann "Create passive mesh rigid bodies from selection";

				 iconTextButton -st "iconAndTextVertical" -l "BvhMesh" -w 75 -i "boingUICreatePassiveBvhMesh.xpm" 
					 -c "boingUIUI_createRigidBody(false, 7)" -ann "Create passive Bvh mesh rigid bodies from selection";

				iconTextButton -st "iconAndTextVertical" -l "Plane" -w 75 -i "boingUICreatePassivePlane.xpm" 
					-c "boingUIUI_createPassivePlane" -ann "Create a passive plane rigid body";
					
				iconTextButton -st "iconAndTextVertical" -l "HACD" -w 75 -i "boingUICreateActiveMesh.xpm"
					-c "boingUIUI_createRigidBody(false, 8)" -ann "Create passive HACD rigid bodies from selection";
					
			setParent ..;
		setParent ..;

		boingUIUI_createFrame("Active Rigid Body Arrays", "Active rigid body arrays are collections of like-shaped active rigid bodies.", 0, 0);
			rowLayout -nc 5;
				iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "boingUICreateActiveSphereArray.xpm"
					-c "boingUIUI_createRigidBodyArray(true, 5)" -ann "Create an active sphere rigid body array";

				iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "boingUICreateActiveBoxArray.xpm" 
					-c "boingUIUI_createRigidBodyArray(true, 4)" -ann "Create an active box rigid body array";

				iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "boingUICreateActiveHullArray.xpm" 
					-c "boingUIUI_createRigidBodyArray(true, 0)" -ann "Create an active hull rigid body array from selection";

				iconTextButton -style "iconAndTextVertical" -label "Mesh" -w 75 -i "boingUICreateActiveMeshArray.xpm" 
					-c "boingUIUI_createRigidBodyArray(true, 1)" -ann "Create an active mesh rigid body array from selection";
			setParent ..;
		setParent ..;

		// boingUIUI_createFrame("Passive Rigid Body Arrays", "Passive rigid body arrays are collections of like-shaped passive rigid bodies.", 0, 0);
			// rowLayout -nc 6;
				// iconTextButton -st "iconAndTextVertical" -l "Sphere" -w 75 -i "boingUICreatePassiveSphereArray.xpm" 
					// -c "boingUIUI_createRigidBodyArray(false, 5)" -ann "Create an passive sphere rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Box" -w 75 -i "boingUICreatePassiveBoxArray.xpm" 
					// -c "boingUIUI_createRigidBodyArray(false, 4)" -ann "Create an passive box rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Hull" -w 75 -i "boingUICreatePassiveHullArray.xpm" 
					// -c "boingUIUI_createRigidBodyArray(false, 0)" -ann "Create an passive hull rigid body array";

				// iconTextButton -st "iconAndTextVertical" -l "Mesh" -w 75 -i "boingUICreatePassiveMeshArray.xpm" 
					// -c "boingUIUI_createRigidBodyArray(false, 1)" -ann "Create an passive mesh rigid body array from selection";

				// iconTextButton -style "iconAndTextVertical" -l "BvhMesh" -w 75 -i "boingUICreatePassiveBvhMeshArray.xpm" 
					// -c "boingUIUI_createRigidBodyArray(false, 1)" -ann "Create an passive Bvh mesh rigid body array from selection";

				// iconTextButton -style "iconAndTextVertical" -l "Plane" -w 75 -i "boingUICreatePassivePlaneArray.xpm" 
					// -c "boingUIUI_createRigidBodyArray(false, 6)" -ann "Create an passive plane rigid body array";
			// setParent ..;
		// setParent ..;

		boingUIUI_createFrame("Constraints", "Constraints inhibit the natural (unconstrained) behavior of an active rigid body.\nConstraints require at least one rigid body to be selected. Rigid bodies can be influenced by multiple constraints.", 0, 0);
			rowLayout -nc 5;
				iconTextButton -st "iconAndTextVertical" -l "Nail" -w 75 -i "boingUICreateNailConstraint.xpm" 
					-c "boingUIUI_createNail" -ann "Create a breakable nail constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "Hinge" -w 75 -i "boingUICreateHingeConstraint.xpm" 
					-c "boingUIUI_createHinge" -ann "Create a breakable hinge constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "Slider" -w 75  -i "boingUICreateSliderConstraint.xpm" 
					-c "boingUIUI_createSlider" -ann "Create a breakable slider constraint";
				
				iconTextButton -st "iconAndTextVertical" -l "6Dof" -w 75 -i "boingUICreate6dofConstraint.xpm" 
					-c "boingUIUI_create6Dof" -ann "Create a breakable 6dof constraint";
	
				// iconTextButton -st "iconAndTextVertical" -l "ConeTwist" -w 75 -i "boingUICreateConeTwistConstraint.xpm" 
					// -c "boingUIUI_createConeTwistConstraint" -ann "Create a cone twist constraint";
			setParent ..;
		setParent ..;
	
		boingUIUI_createFrame("Soft Bodies (experimental)", "Soft bodies include cloth and ropes .", 0, 0);
			rowLayout -nc 1;
				iconTextButton -st "iconAndTextVertical" -l "Soft Mesh" -w 75 -i "boingUISoftMesh.xpm"
					-c "boingUIUI_createSoftBody()" -ann "Convert mesh to soft body";
				
			setParent ..;
		setParent ..;
	setParent ..;
	
	return $mainForm;
}

global proc string boingUIUI_createControlTab() 
{
	global float $boingUIUI_activeStartFrame = 24;
	global float $boingUIUI_activeEndFrame = 48;
	global int $boingUIUI_activateAxis = 0; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain

	string $mainForm = `columnLayout -adj 1`;

		boingUIUI_createFrame("Frame Range For Rigid Body Control", "Selected rigid bodies will become active during this range", 0, 0);
			rowLayout -nc 2;
				floatField -pre 3 -w 60 -v $boingUIUI_activeStartFrame -ann "Activation range start frame"
					-cc "$boingUIUI_activeStartFrame = `floatField -q -v activateStart`" activateStart;
				floatField -pre 3 -w 60 -v $boingUIUI_activeEndFrame -ann "Activation range end frame"
					-cc "$boingUIUI_activeEndFrame = `floatField -q -v activateEnd`" activateEnd;
			setParent ..;
		setParent ..;

		boingUIUI_createFrame("Make Rigid Bodies Active Along The X, Y, or Z Axis", "Make selected rigid bodies active along a world axis.", 0, 0);
			rowLayout -nc 6;
				iconTextButton -st "iconAndTextVertical" -l "+X Axis" -w 75 -i "boingUIActivateX.xpm" 
					-c "boingUIUI_activateAxis(0)" -ann "Activate selected rigid bodies along the +X axis";
				iconTextButton -st "iconAndTextVertical" -l "-X Axis" -w 75 -i "boingUIActivate-X.xpm" 
					-c "boingUIUI_activateAxis(1)" -ann "Activate selected rigid bodies along the -X axis";
				iconTextButton -st "iconAndTextVertical" -l "+Y Axis" -w 75 -i "boingUIActivateY.xpm" 
					-c "boingUIUI_activateAxis(2)" -ann "Activate selected rigid bodies along the +Y axis";
				iconTextButton -st "iconAndTextVertical" -l "-Y Axis" -w 75 -i "boingUIActivate-Y.xpm" 
					-c "boingUIUI_activateAxis(3)" -ann "Activate selected rigid bodies along the -Y axis";
				iconTextButton -st "iconAndTextVertical" -l "+Z Axis" -w 75 -i "boingUIActivateZ.xpm" 
					-c "boingUIUI_activateAxis(4)" -ann "Activate selected rigid bodies along the +Z axis";
				iconTextButton -st "iconAndTextVertical" -l "-Z Axis" -w 75 -i "boingUIActivate-Z.xpm" 
					-c "boingUIUI_activateAxis(5)" -ann "Activate selected rigid bodies along the -Z axis";
			setParent ..;
		setParent ..;
		
		boingUIUI_createFrame("Make Rigid Bodies Active In A Radial Or Chain Pattern", "Make selected rigid bodies active in a radial or chain pattern, starting with the active object in the selection.", 0, 0);
			rowLayout -nc 3;
				iconTextButton -st "iconAndTextVertical" -l "Outward" -w 75 -i "boingUIActivateRadial.xpm" 
					-c "boingUIUI_activateAxis(6)" -ann "Radially activate selected rigid bodies outwards";
				iconTextButton -st "iconAndTextVertical" -l "Inward" -w 75 -i "boingUIActivateRadialIn.xpm" 
					-c "boingUIUI_activateAxis(7)" -ann "Radially activate selected rigid bodies inwards";
				iconTextButton -st "iconAndTextVertical" -l "Daisy Chain" -w 75 -i "boingUIActivateChain.xpm" 
					-c "boingUIUI_activateAxis(8)" -ann "Chain activate selected rigid bodies";
			setParent ..;
		setParent ..;
		
		boingUIUI_createFrame("Configure & Modify Rigid Bodies (frame range ignored)", "Restore default active behavior, convert to passive, or set the initial state of selected rigid bodies.", 0, 0);
			rowLayout -nc 4;
				iconTextButton -st "iconAndTextVertical" -l "Make Active" -w 75 -i "boingUIUnactivate.xpm" 
					-c "boingUIUI_deactivateRigidBodies(0)" -ann "Make selected rigid bodies active (restores default behavior)";
				iconTextButton -st "iconAndTextVertical" -l "Make Passive" -w 75 -i "boingUIMakePassive.xpm" 
					-c "boingUIUI_deactivateRigidBodies(1)" -ann "Make selected rigid bodies passive";
				iconTextButton -st "iconAndTextVertical" -l "Set Initial State" -w 85 -i "boingUISetInitialState.xpm" 
					-c "boingUIUI_setInitialState(0)" -ann "Set current state to initial state";
				iconTextButton -st "iconAndTextVertical" -l "Clear Initial State" -w 85 -i "boingUIClearInitialState.xpm" 
					-c "boingUIUI_setInitialState(1)" -ann "Restore original initial state";
			setParent ..;
		setParent ..;
	setParent ..;

	return $mainForm;
}

global proc string boingUIUI_createCaptureTab() 
{
	global int $boingUIUI_deleteEmptyNodes = 1;
	global int $boingUIUI_deleteBakeHistory = 1;
	global int $boingUIUI_deleteStaticChannels = 1;
	global int $boingUIUI_optimizeChannels = 1;
	global int $boingUIUI_captureAll = 1;
	global float $boingUIUI_captureStartFrame;
	global float $boingUIUI_captureEndFrame;
	
	float $start = `playbackOptions -q -min`;
	float $end = `playbackOptions -q -max`;

	string $mainForm = `columnLayout -adj 1`;
		boingUIUI_createFrame("Frame Range To Bake", "Set the starting and ending frames for baking.", 0, 0);
			rowLayout -nc 2;
				floatField -pre 3 -w 60 -v $start
					-cc "if (`floatField -q -v bakeStart` > `floatField -q -v bakeEnd`) floatField -e -v (`floatField -q -v bakeStart`) bakeEnd;$boingUIUI_captureStartFrame = `floatField -q -v bakeStart`" bakeStart;
				floatField -pre 3 -w 60 -v $end
					-cc "if (`floatField -q -v bakeStart` > `floatField -q -v bakeEnd`) floatField -e -v (`floatField -q -v bakeEnd`) bakeStart;$boingUIUI_captureEndFrame = `floatField -q -v bakeEnd`" bakeEnd;
				$boingUIUI_captureStartFrame = `floatField -q -v bakeStart`;
				$boingUIUI_captureEndFrame = `floatField -q -v bakeEnd`;
			setParent ..;
		setParent ..;
		
		boingUIUI_createFrame("Bake Selected Or All Rigid Bodies", "Bake keyframe data for selected or all rigid bodies in the scene.", 0, 0);
			rowLayout -nc 2;
				iconTextButton -st "iconAndTextVertical" -l "Bake Selected" -w 85 -i "boingUIBakeSelected.xpm" 
					-c "$boingUIUI_captureAll = 0; boingUIUI_bakeRigidBodies()" -ann "Bake Selected Rigid Bodies";
				iconTextButton -st "iconAndTextVertical" -l "Bake All" -w 75 -i "boingUIBakeAll.xpm" 
					-c "$boingUIUI_captureAll = 1; boingUIUI_bakeRigidBodies()" -ann "Bake All Rigid Bodies";
			setParent ..;
		setParent ..;
		
		boingUIUI_createFrame("Bake Options", "Enabling these options can dramatically reduce scene size and overhead.", 1, 1);
			columnLayout;
				checkBox -l "Optimize Channels (Recommended)" -v $boingUIUI_optimizeChannels -ann "Remove unneccassary keyframes (significantly reduces data and file size)" 
					-cc "$boingUIUI_optimizeChannels  = `checkBox -q -v bakeOptimize`" bakeOptimize;
				checkBox -l "Delete History (Recommended)" -v $boingUIUI_deleteBakeHistory -ann "Delete history on all baked objects" 
					-cc "$boingUIUI_deleteBakeHistory  = `checkBox -q -v bakeHistory`" bakeHistory;
				checkBox -l "Delete Empty Nodes (Recommended)" -v $boingUIUI_deleteEmptyNodes -ann "Remove empty and orphaned nodes" 
					-cc "$boingUIUI_deleteEmptyNodes  = `checkBox -q -v bakeEmpty`" bakeEmpty;
			setParent ..;
		setParent ..;
	setParent ..;

	return $mainForm;
}

global proc string boingUIUI_createOptionsTab()
{	
	global string $boingUIUI_STsolverType;
	global string $boingUIUI_STgravityX;
	global string $boingUIUI_STgravityY;
	global string $boingUIUI_STgravityZ;
	global string $boingUIUI_STenabled;
	global string $boingUIUI_STsplitImpulse;
	global string $boingUIUI_STsubsteps;
	global string $boingUIUI_STphysicsrate;
	global string $boingUIUI_STcollisionMargin;
	global string $boingUIUI_activateSet;
	global float $boingUIUI_collisionMargin;
	global float $boingUIUI_crackWidth;
	global int $boingUIUI_createActivateSet = 1;
	
	string $mainForm = `columnLayout -adj 1`;
	
		boingUIUI_createFrame("Solver Options", "", 1, 0);
			columnLayout;
				rowLayout -nc 2;
					columnLayout -w 220;
						text -al "left" -fn "boldLabelFont" -l "Gravity" -ann "Direction and magnitude of gravity in the simulation.";
						float $gravity[] = `getAttr dSolver1.gravity`;
						rowLayout -nc 3;
							$boingUIUI_STgravityX = `floatField -pre 3 -w 50 -v $gravity[0]`;
							$boingUIUI_STgravityY = `floatField -pre 3 -w 50 -v $gravity[1]`;
							$boingUIUI_STgravityZ = `floatField -pre 3 -w 50 -v $gravity[2]`;
							connectControl $boingUIUI_STgravityX dSolver1.gravityX;
							connectControl $boingUIUI_STgravityY dSolver1.gravityY;
							connectControl $boingUIUI_STgravityZ dSolver1.gravityZ;
						setParent ..;
					setParent ..;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Physics Framerate (Hertz)";
						int $physicsrate= `getAttr dSolver1.physicsrate`; 
						$boingUIUI_STphysicsrate = `intField -v $physicsrate -w 50 -ann "Default is 240. Higher values \"speed up\" simulation"`;
						connectControl $boingUIUI_STphysicsrate dSolver1.physicsrate;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout -w 220;
						text -al "left" -fn "boldLabelFont" -l "Substeps";
						int $substeps = `getAttr dSolver1.substeps`; 
						$boingUIUI_STsubsteps = `intField -v $substeps -w 50 
							-ann "Number of times the simulation is evaluated 'between' each frame step on the timeline.\nThe default value of 1 should work for most simulations."`;
						connectControl $boingUIUI_STsubsteps dSolver1.substeps;
					setParent ..;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Split Impulse";
						int $enabled = `getAttr dSolver1.splitImpulse`;
						$boingUIUI_STsplitImpulse = `checkBox -l "Enabled" -v $enabled 
							-ann "Enabling Split Impulse will allow the solver to apply positional corrections when deep collision penetrations occur.\nThese corrections do not affect resulting velocities."`;
						connectControl $boingUIUI_STsplitImpulse dSolver1.splitImpulse;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Solver State";
						int $enabled = `getAttr dSolver1.enabled`;
						$boingUIUI_STenabled = `checkBox -l "Enabled" -v $enabled 
							-ann "Toggles the state of the solver - like an on/off switch."`;
						connectControl $boingUIUI_STenabled dSolver1.enabled;
					setParent ..;
					columnLayout;
						//
					setParent ..;
				setParent ..;
			setParent ..;
		setParent ..;
		
		boingUIUI_createFrame("Tool Options", "", 1, 0);
			columnLayout;
				rowLayout -nc 2;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Colision Margin (creation only)";
						$boingUIUI_collisionMargin = `getAttr dSolver1.collisionMargin`; 
						$boingUIUI_STcollisionMargin = `floatField -pre 3 -w 50 -v $boingUIUI_collisionMargin 
							-ann "The gap around each collision shape used for collision detection.\nThis value only effects Hull and Mesh rigid bodies during creation. Default is 0.040." 
							-cc "$boingUIUI_collisionMargin = `floatField -q -v $boingUIUI_STcollisionMargin`"`;
						connectControl $boingUIUI_STcollisionMargin dSolver1.collisionMargin;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 1;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Disable Collisions Between Constrained Bodies (creation only)";
						int $enabled = `getAttr dSolver1.disableCollisionsBetweenLinkedBodies`;
						$boingUIUI_disableCollisionsBetweenLinkedBodies = `checkBox -l "Enabled" -v $enabled 
							-ann "Controls the collisions of rigid bodies which share a constraint. This only effects constraints during creation."`;
						connectControl $boingUIUI_disableCollisionsBetweenLinkedBodies dSolver1.disableCollisionsBetweenLinkedBodies;
					setParent ..;
				setParent ..;
				
				rowLayout -nc 2;
					columnLayout;
						text -al "left" -fn "boldLabelFont" -l "Create Control Sets";
						$boingUIUI_activateSet = `checkBox -l "Enabled" -v $boingUIUI_createActivateSet 
							-ann "Creates quick select sets containing rigid bodies modified by activation controls." 
							-cc "$boingUIUI_createActivateSet = `checkBox -q -v $boingUIUI_activateSet`"`;
					setParent ..;
					columnLayout;
						//
					setParent ..;
				setParent ..;
				
				separator -h 10;
				button -l "Toggle Advanced Tools Tab" -c "boingUIUI_tools()";
			setParent ..;
		setParent ..;
		
	setParent ..;

	return $mainForm;
}

//*****************
//<rp 2014>
//*****************
global proc string boingUIUI_createCallBacksTab()
{
	string $mainForm = `columnLayout -adj 1`;
        boingUIUI_createFrame("Edit callbacks", "", 0, 0);
            rowLayout -nc 2;
                iconTextButton -st "iconAndTextVertical" -l "Create callback" -w 75 -i "boingUIHelp.xpm"
                -c "createNode dCallBack" -ann "Create callback";
                iconTextButton -st "iconAndTextVertical" -l "Delete callback" -w 75 -i "boingUIBulletWebsite.xpm"
                -c "system(\"load http://bulletphysics.org\")" -ann "Visit bulletphysics.org";
            setParent ..;
        setParent ..;
    
        //boingUIUI_createFrame("Callback", "", 0, 0);
            columnLayout;
    
            textScrollList -allowMultiSelection true
                -append "Only two things are infinite, the universe and human stupidity, and I'm not sure about the former."
                -uniqueTag "Albert Einstein"
                -append "Each problem that I solved became a rule, which served afterwards to solve other problems."
                -uniqueTag "Rene Descartes"
                myControlObj;

            setParent ..;
        //setParent ..;
    
	setParent ..;
    
	return $mainForm;
}
//*****************
//</rp 2014>
//*****************

global proc string boingUIUI_createHelpTab()
{	
	string $mainForm = `columnLayout -adj 1`;
		boingUIUI_createFrame("Documentation & Resources", "View the online wiki documentation or bulletphysics.org", 0, 0);
			rowLayout -nc 2;
				iconTextButton -st "iconAndTextVertical" -l "Online Help" -w 75 -i "boingUIHelp.xpm" 
					-c "system(\"load http://code.google.com/p/boingUI/wiki/boingUIIntroduction\")" -ann "View Online Documentation";
				iconTextButton -st "iconAndTextVertical" -l "bulletphysics.org" -w 90 -i "boingUIBulletWebsite.xpm" 
					-c "system(\"load http://bulletphysics.org\")" -ann "Visit bulletphysics.org";
			setParent ..;
		setParent ..;
		
		boingUIUI_createFrame("Credits", "", 0, 0);
			columnLayout;
				text -al "left" -l "Original Plugin: Walt Disney Studios";
				text -al "left" -l "Original Author: Nicola Candussi";
				text -al "left" -l "Modified By: Roman Ponomarev, Erwin Coumans";
				text -al "left" -l "Tools, Features, UI & Maintenance: Michael Baker";
				text -al "left" -l "Original Baking Scripts: RBD";
				setParent ..; //This is the additional setParent needed for MAYA 2009/2010.
			setParent ..;
		setParent ..;
		
	setParent ..;

	return $mainForm;
}

global proc string boingUIUI_createFrame(string $label, string $annotation, int $collapsable, int $collapsed)
{
	return `frameLayout -cll $collapsable -cl $collapsed -mh 3 -mw 6 -w 486 -h 100 -bs "etchedIn" -l $label -ann $annotation`;
}

global proc string boingUIUI_loadHelp()
{
	string $path = `file -query -location "boingUI.mel"`;
	$path = strip(`substitute "boingUI.mel" $path ""`);
	$path = `substitute "scripts" $path "doc"`;
	$path += "HELP.txt";

	int $fid = `fopen $path "r"`;
	string $line = `fgetline $fid`;
	string $fileData = $line;
	while (size($line) > 0)
	{
		$line =`fgetline $fid`;
		$fileData += $line;
	}
	fclose $fid;
	return $fileData;
}

global proc boingUIUI_print(string $out, int $mode)
{
	//modes: 0 = print, 1 = warning, 2 = error
	global string $boingUIUI_helpLine;
	
	if ($mode == 0)
	{
		if(`textField -ex $boingUIUI_helpLine`) textField -e -bgc 0.8 0.9 0.8 -tx ("boingUI: " + $out) $boingUIUI_helpLine;
		print("boingUI: " + $out + "\n");
	}
	else if ($mode == 1)
	{
		if(`textField -ex $boingUIUI_helpLine`) textField -e -bgc 1.0 1.0 0.8 -tx ("boingUI: " + $out) $boingUIUI_helpLine;
		warning("boingUI Warning: " + $out + "\n");
	}
	else if ($mode == 2)
	{
		if(`textField -ex $boingUIUI_helpLine`) textField -e -bgc 1.0 0.6 0.6 -tx ("boingUI: " + $out) $boingUIUI_helpLine;
		error("boingUI Error: " + $out + "\n");
	}
	refresh;
}

global proc boingUIUI_relinkRigidBodies()
{
	$sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "bSolver") && ($s != "bSolverMain"))
	{
		delete $s;
	}
	$sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "boingRb"))
	{
		if (`isConnected |dDebugDraw|dSolver1.rigidBodies ($s+".solver")`)
		{
			disconnectAttr |dDebugDraw|dSolver1.rigidBodies ($s+".solver") ;
		}
	}
	$sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "boingRb"))
	{
		// $ll = longNameOf($s);
		//print $s;	print " ----";
		if (!`isConnected |dDebugDraw|dSolver1.rigidBodies ($s+".solver")`)
		{
			connectAttr -f |dDebugDraw|dSolver1.rigidBodies ($s+".solver") ;
		}
	}
}

//repeatable argless commands
global proc boingUIUI_createActiveSphere() { boingUIUI_createRigidBody(true, 5); }

global proc boingUIUI_createActiveBox() { boingUIUI_createRigidBody(true, 4); } 

global proc boingUIUI_createActiveHull() { boingUIUI_createRigidBody(true, 0); }

global proc boingUIUI_createActiveMesh() { boingUIUI_createRigidBody(true, 1); }

global proc boingUIUI_createPassiveSphere() { boingUIUI_createRigidBody(false, 5); }

global proc boingUIUI_createPassiveBox() { boingUIUI_createRigidBody(false, 4); }

global proc boingUIUI_createPassiveHull() { boingUIUI_createRigidBody(false, 0); }

global proc boingUIUI_createPassiveMesh()  { boingUIUI_createRigidBody(false, 1); }

global proc boingUIUI_createPassiveHACD()  { boingUIUI_createRigidBody(false, 8); }

global proc boingUIUI_createPassivePlane()  { boingUIUI_createRigidBody(false, 6); }

global proc boingUIUI_createNail() { boingUIUI_createConstraint(0); }

global proc boingUIUI_createHinge() { boingUIUI_createConstraint(1); }

global proc boingUIUI_createSlider() { boingUIUI_createConstraint(2); }

global proc boingUIUI_create6Dof() { boingUIUI_createConstraint(3); }
//end commands



global proc boingUIUI_createSoftBody()
{
	
	global float $boingUIUI_startFrame;
	global float $boingUIUI_collisionMargin;
	dSolver;
	$boingUIUI_collisionMargin = `getAttr dSolver1.collisionMargin`; 
	string $meshLayer = "boingUIInputMeshes";
	string $sbLayer = "boingUISoftBodies";
	string $obSelection[] = `ls -sl`;
	string $selection[];
	string $newBodies[];
	string $sbGroup;
	string $meshGroup;
	string $margin;
	int $bodyCount = 0;
	int $makeCollisionShape = 1;
	float $collisionMargin = $boingUIUI_collisionMargin * 1.75; //compensate for descrepancy between Maya vertex shift and Bullet planar shift
	
	for ($o in $obSelection) mbDeleteShapeHistory($o); //clean shape history
	$selection = `ls -selection -dag -leaf -showType -type "geometry"`;
	
	
	string $softBodyNode;
	// if there is actually a selection
	if (size($selection) > 0)
	{
		boingUIUI_print("Creating boing soft bodies...", 0);
		refresh;
		// //create groups and layers if necessary
		// $sbGroup = `group -em -n dSoftBodies`;
		$meshGroup = `group -em -n dMeshes`;
		
		// mbHideAndLockTransform($sbGroup);
		mbHideAndLockTransform($meshGroup);
		mbCreateLayer($meshLayer, 1);
		mbCreateLayer($sbLayer, 0);
		setAttr ($sbLayer + ".shading") 0; //disable shading
	
		for ($i = 0; $i < size($selection) / 2; $i++)
		{
			string $marginShape = mbGetShape($obSelection[$i]);			
			
			if (mbIsMesh($obSelection[$i]))
			{
				
					
				if(mbIsKeyed($obSelection[$i]))
				{
					warning($obSelection[$i] + "'s transform is keyed, unable to convert to soft-body...");					
					return;
				}
								
				
				
				string $shapeTransforms[] = `listRelatives -p -f -pa $selection[$i * 2]`;
				$softBodyNode = `dSoftBody`;
				float $pos[]= `getAttr ($shapeTransforms[0] + ".translate")`;
				float $rot[]= `getAttr ($shapeTransforms[0] + ".rotate")`;
				
				// freeze transformations on selected object
				makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $obSelection[$i];
				delete -ch $obSelection[$i];				
			
				// duplicate input object for output mesh.  Input object should be unchangeable so that soft body can be returned to original shape
				// also add attribute to connect input mesh to soft body
				addAttr -ln "outSoftBody" -at message $marginShape;
				connectAttr ($marginShape + ".outSoftBody") ($softBodyNode + ".inMesh");
				$dup = `duplicate $obSelection[$i]`;
				$outShape = mbGetShape($dup[0]);
				string $outTransform[] =  `listRelatives -p -f -pa $outShape`;
								
				// hide and lock the output mesh transforms;
				mbHideAndLockTransform($dup[0]);
				
				// hide input mesh 
				setAttr($obSelection[$i] + ".visibility") 0;

				// create attribute in duplicate mesh to connect soft body node to out mesh
				addAttr -ln "inSoftBody" -at message $outShape;
				connectAttr($softBodyNode + ".outMesh") ($outShape + ".inSoftBody");	
				// set collision margin.
				// is this the correct way to do it?
				setAttr($softBodyNode + ".collisionmargin") $collisionMargin;
				
				// mbHideAndLockTransform($dup[0]);
				string $softBodyTransforms[] = `listRelatives -p $softBodyNode`;
				if ($selection[$i * 2 + 1] == "mesh") {
					setAttr ($softBodyTransforms[0] + ".overrideEnabled") 1;
					setAttr ($softBodyTransforms[0] + ".overrideShading") 0;
				}			
								
				setAttr ($softBodyTransforms[0] + ".translate") -typ double3 $pos[0] $pos[1] $pos[2];
				setAttr ($softBodyNode + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
				setAttr ($softBodyTransforms[0] + ".rotate") -typ double3 $rot[0] $rot[1] $rot[2];
				setAttr ($softBodyNode + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
				
				//store original position and rotation
				addAttr -ln "originalPosition" -at double3 -k 0 $softBodyTransforms[0];
				addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $softBodyTransforms[0];
				addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $softBodyTransforms[0];
				addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $softBodyTransforms[0];
				
				addAttr -ln "originalRotation" -at double3 -k 0 $softBodyTransforms[0];
				addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $softBodyTransforms[0];
				addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $softBodyTransforms[0];
				addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $softBodyTransforms[0];
				
				// connect original mesh transform to rigid body transform
				// connectAttr ($softBodyTransforms[0] + ".translate") ($outTransform[0] + ".translate");
				// connectAttr ($softBodyTransforms[0] + ".rotate") ($outTransform[0] + ".rotate");
				// connectAttr ($softBodyTransforms[0] + ".scale") ($outTransform[0] + ".scale");
				
				$newBodies[$i] = $softBodyNode;
				//add to groups and layers
				mbAddToLayer($obSelection[$i], $meshLayer); //editDisplayLayerMembers -nr $meshLayer $shapeTransforms[0];
				// mbAddToLayer($softBodyTransforms[0], $sbLayer);
								
				parent $obSelection[$i] $meshGroup;
				// parent $softBodyTransforms[0] $sbGroup;
				// parent $softBodyNode $outShape;
				$bodyCount++;
				refresh;
			}
			else {
				boingUIUI_print($obSelection[$i] + " is not a Polymesh, soft body not created!", 1);
			}
		}
		//else {
				//boingUIUI_print($shapeTransforms[0] + " is already a soft body", 1);			
			// $makeCollisionShape = 1;
		//  }
		// if ($bodyCount) boingUIUI_print("Created " + $bodyCount + " rigid bodies. Find rigid bodies and source meshes in Outliner and Display Layers.", 0);
	}
	else
	{
		boingUIUI_print("Unable to create soft body(s), select Polymesh objects first...", 1);
	}
	currentTime $boingUIUI_startFrame;
	select -r $newBodies;
}







global proc boingUIUI_createRigidBody(int $activebody, int $collisionShapeType)
{	//collision shape types: 0 = Hull, 1 = Mesh, 2 = Cylinder, 3 = Capsule, 4 = Box, 5 = Sphere, 6 = Plane
	
	dSolver; //create dSolver node if necessary

	
	global float $boingUIUI_startFrame;
	global float $boingUIUI_collisionMargin;
	$boingUIUI_collisionMargin = `getAttr bSolver1.collisionMargin`;
	float $mass = 1; 
	string $meshLayer = "boingUIInputMeshes";
	string $rbLayer = "boingUIRigidBodies";
	string $obSelection[] = `ls -sl`;
	string $selection[];
	string $newBodies[];
	string $rbGroup;
	string $meshGroup;
	string $margin;
	int $bodyCount = 0;
	int $makeCollisionShape = 1;
	float $collisionMargin = $boingUIUI_collisionMargin * 1.75; //compensate for descrepancy between Maya vertex shift and Bullet planar shift
	

	for ($o in $obSelection) mbDeleteShapeHistory($o); //clean shape history
	$selection = `ls -selection -dag -leaf -showType -type "geometry"`;
	
	if ($activebody == false) $mass = 0;
	
	
	//pick the selected object's transform only if we are creating a hull or a mesh
	if ($collisionShapeType == 0 || $collisionShapeType == 1 || $collisionShapeType == 7 || $collisionShapeType == 8) 
	{
		string $isGroup = mbSelectionIsGroup($obSelection[0]);

		string $rigidBodyNode;
		
		if (size($selection))
		{
			boingUIUI_print("Creating boing rigid bodies...", 0);
			refresh;
			//create groups and layers if necessary
			//$rbGroup = `group -em -n dRigidBodies`;
			//$meshGroup = `group -em -n dMeshes`;
			//mbHideAndLockTransform($rbGroup);
			//mbHideAndLockTransform($meshGroup);
			//mbCreateLayer($meshLayer, 1);
			//mbCreateLayer($rbLayer, 0);
			//setAttr ($rbLayer + ".shading") 0; //disable shading
		
			if ($isGroup)
			{
				print("it is a group\n");
				
				$marginShape = $obSelection[0];
				print("it is a group!\n");
				
				///is the selection already turned into a rigid body?
				for ($i = 0; $i < size($selection) / 2; $i++)
				{
					string $connectedCollisionShapes[] = `listConnections -s 1 -t dCollisionShape $selection[$i * 2]`;
					if(size($connectedCollisionShapes) > 0) 
						$makeCollisionShape = 0;
				}
				
				if ($makeCollisionShape)
				{
					$rigidBodyNode = `dRigidBody`;
							
					string $collisionShapeNode = `createNode dCollisionShape`;
					//print("$collisionShapeNode = "+$collisionShapeNode+ "\n");
					connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyNode + ".inCollisionShape");
					
					string $rigidBodyTransforms[] = `listRelatives -p $rigidBodyNode`;
					$sz = size($rigidBodyTransforms);
					//print("size($rigidBodyTransforms) = "+$sz + "\n");

					///assume at least one mesh in the group
					if ($selection[1] == "mesh") 
					{
						connectAttr ($marginShape + ".message") ($collisionShapeNode + ".inShape");
						setAttr ($rigidBodyTransforms[0] + ".overrideEnabled") 1;
						setAttr ($rigidBodyTransforms[0] + ".overrideShading") 0;		
					}
					if (mbIsKeyed($obSelection[0]))
					{
						warning($obSelection[0] + "'s transform is keyed, creating kinematic collider...");
						$mass = 0;
						mbTransferKeys($obSelection[0], $rigidBodyTransforms[0], 1);
					}

					//make each child shape a parent of the rigid body
				
				
					for ($i = 0; $i < size($selection) / 2; $i++)
					{
						string $shapeTransforms[] = `listRelatives -p -f -pa $selection[$i * 2]`;
						//print("size($shapeTransforms) = "+size($shapeTransforms) + "\n");
						//print("$shapeTransforms[0] = "+$shapeTransforms[0]+"\n");
						//parent $shapeTransforms[0] $rigidBodyNode;
					}

					setAttr ($rigidBodyNode + ".mass" ) $mass;
					setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
					
					float $pos[]= `getAttr ($obSelection[0] + ".translate")`;
					float $rot[]= `getAttr ($obSelection[0] + ".rotate")`;

					setAttr ($rigidBodyTransforms[0] + ".translate") -typ double3 $pos[0] $pos[1] $pos[2];
					setAttr ($rigidBodyNode + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
					setAttr ($rigidBodyTransforms[0] + ".rotate") -typ double3 $rot[0] $rot[1] $rot[2];
					setAttr ($rigidBodyNode + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
					
					//store original position and rotation
					addAttr -ln "originalPosition" -at double3 -k 0 $rigidBodyTransforms[0];
					addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $rigidBodyTransforms[0];
					addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $rigidBodyTransforms[0];
					addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $rigidBodyTransforms[0];
					addAttr -ln "originalRotation" -at double3 -k 0 $rigidBodyTransforms[0];
					addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $rigidBodyTransforms[0];
					addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $rigidBodyTransforms[0];
					addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $rigidBodyTransforms[0];
					
					//connect original mesh transform to rigid body transform
					connectAttr ($rigidBodyTransforms[0] + ".translate") ($obSelection[0] + ".translate");
					connectAttr ($rigidBodyTransforms[0] + ".rotate") ($obSelection[0] + ".rotate");
					connectAttr ($rigidBodyTransforms[0] + ".scale") ($obSelection[0] + ".scale");
			
								
					$newBodies[0] = $rigidBodyTransforms[0];
					//print("f ==================================================\n");
					//add to groups and layers
					mbAddToLayer($obSelection[0], $meshLayer); //editDisplayLayerMembers -nr $meshLayer $shapeTransforms[0];
					mbAddToLayer($rigidBodyTransforms[0], $rbLayer);
					parent $obSelection[0] $meshGroup;
					parent $rigidBodyTransforms[0] $rbGroup;
					$bodyCount++;
					//print("g ==================================================\n");
					refresh;
				}
				
			} else
			{
				print("it is not a group\n");

				for ($i = 0; $i < size($selection) / 2; $i++)
				{
					string $marginShape = mbGetShape($obSelection[$i]);
					string $connectedCollisionShapes[] = `listConnections -s 1 -t dCollisionShape $selection[$i * 2]`;
					if(size($connectedCollisionShapes) > 0) $makeCollisionShape = 0;
					
					string $shapeTransforms[] = `listRelatives -p -f -pa $selection[$i * 2]`;
	
					if ($makeCollisionShape)
					{
						if (mbIsMesh($obSelection[$i]))
						{
							if (!mbIsKeyed($obSelection[$i])) //process transform if not keyed
							{
								mbFreezeScale($obSelection[$i]);
								mbUnFreezeTranslation($obSelection[$i]);
								
								//process collision margin if active
								if ($activebody) 
								{
									$dup = `duplicate $obSelection[$i]`;
									$marginShape = mbGetShape($dup[0]);
									setAttr ($marginShape + ".visibility") 0;
									$margin = mbDeflate($marginShape, $collisionMargin);
									parent -s -add $marginShape $obSelection[$i];
									delete $dup;
									delete -ch $obSelection[$i];
									string $shapes[] = mbGetShapes($obSelection[$i]);
									$marginShape = $shapes[1]; //update marginShape
								}
							}
	
							$rigidBodyNode = `boingRb`;
							string $collisionShapeNode = `createNode dCollisionShape`;
							connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyNode + ".inCollisionShape");
							string $rigidBodyTransforms[] = `listRelatives -p $rigidBodyNode`;
							
							if ($selection[$i * 2 + 1] == "mesh") {
								connectAttr ($marginShape + ".message") ($collisionShapeNode + ".inShape");
								setAttr ($rigidBodyTransforms[0] + ".overrideEnabled") 1;
								setAttr ($rigidBodyTransforms[0] + ".overrideShading") 0;		
							}
							
							if (mbIsKeyed($obSelection[$i]))
							{
								warning($obSelection[$i] + "'s transform is keyed, creating kinematic collider...");
								$mass = 0;
								mbTransferKeys($obSelection[$i], $rigidBodyTransforms[0], 1);
							}
							
							setAttr ($rigidBodyNode + ".mass" ) $mass;
							setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
	
							float $pos[]= `getAttr ($shapeTransforms[0] + ".translate")`;
							float $rot[]= `getAttr ($shapeTransforms[0] + ".rotate")`;
	
							setAttr ($rigidBodyTransforms[0] + ".translate") -typ double3 $pos[0] $pos[1] $pos[2];
							setAttr ($rigidBodyNode + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
							setAttr ($rigidBodyTransforms[0] + ".rotate") -typ double3 $rot[0] $rot[1] $rot[2];
							setAttr ($rigidBodyNode + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
							
							//store original position and rotation
							addAttr -ln "originalPosition" -at double3 -k 0 $rigidBodyTransforms[0];
							addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $rigidBodyTransforms[0];
							addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $rigidBodyTransforms[0];
							addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $rigidBodyTransforms[0];
							addAttr -ln "originalRotation" -at double3 -k 0 $rigidBodyTransforms[0];
							addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $rigidBodyTransforms[0];
							addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $rigidBodyTransforms[0];
							addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $rigidBodyTransforms[0];
							
							//connect original mesh transform to rigid body transform
							connectAttr ($rigidBodyTransforms[0] + ".translate") ($shapeTransforms[0] + ".translate");
							connectAttr ($rigidBodyTransforms[0] + ".rotate") ($shapeTransforms[0] + ".rotate");
							connectAttr ($rigidBodyTransforms[0] + ".scale") ($shapeTransforms[0] + ".scale");
							
							$newBodies[$i] = $rigidBodyTransforms[0];
							
							//add to groups and layers
							mbAddToLayer($obSelection[$i], $meshLayer); //editDisplayLayerMembers -nr $meshLayer $shapeTransforms[0];
							mbAddToLayer($rigidBodyTransforms[0], $rbLayer);
							parent $obSelection[$i] $meshGroup;
							parent $rigidBodyTransforms[0] $rbGroup;
							$bodyCount++;
							
							refresh;
							//if ($activebody) mbUnflate($margin); //if active, restore shape
						}
						else
						{
							boingUIUI_print($obSelection[$i] + " is not a Polymesh, rigid body not created!", 1);
						}
					}
					else
					{
						boingUIUI_print($shapeTransforms[0] + " is already a rigid body", 1);
						//$newBodies[$i] = $shapeTransforms[0];
					}
					
					$makeCollisionShape = 1;
				}
			}
			if ($bodyCount) boingUIUI_print("Created " + $bodyCount + " rigid bodies. Find rigid bodies and source meshes in Outliner and Display Layers.", 0);
		}
		else
		{
			boingUIUI_print("Unable to create rigid body(s), select Polymesh objects first...", 1);
		}
	} 
	else //create primitive
	{
		string $rigidBodyNode = `dRigidBody`;
		string $collisionShapeNode = `createNode dCollisionShape`;
		connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyNode + ".inCollisionShape");
		string $rigidBodyTransforms[] = `listRelatives -parent $rigidBodyNode`;

		setAttr ($rigidBodyNode + ".mass" ) $mass;
		setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
		
		float $pos[]= `getAttr ($rigidBodyTransforms[0] + ".translate")`;
		float $rot[]= `getAttr ($rigidBodyTransforms[0] + ".rotate")`;
						
		//store original position and rotation
		addAttr -ln "originalPosition" -at double3 -k 0 $rigidBodyTransforms[0];
		addAttr -ln "originalPositionX" -at double -k 0 -dv $pos[0] $rigidBodyTransforms[0];
		addAttr -ln "originalPositionY" -at double -k 0 -dv $pos[1] $rigidBodyTransforms[0];
		addAttr -ln "originalPositionZ" -at double -k 0 -dv $pos[2] $rigidBodyTransforms[0];
		addAttr -ln "originalRotation" -at double3 -k 0 $rigidBodyTransforms[0];
		addAttr -ln "originalRotationX" -at double -k 0 -dv $rot[0] $rigidBodyTransforms[0];
		addAttr -ln "originalRotationY" -at double -k 0 -dv $rot[1] $rigidBodyTransforms[0];
		addAttr -ln "originalRotationZ" -at double -k 0 -dv $rot[2] $rigidBodyTransforms[0];

		$newBodies[0] = $rigidBodyTransforms[0];
		boingUIUI_print("Created rigid body primitive: " + $rigidBodyNode, 0);
	}

	
	currentTime $boingUIUI_startFrame; //force refresh
	select -r $newBodies;
}

global proc string boingUIUI_createConstraint(int $constraintType)
{
	//0 = Nail, 1 = Hinge, 2 = Slider, 3 = 6Dof
	string $selection[] = `ls -sl`;
	string $constraintTransforms[];
	$selection = `listRelatives -s $selection`;
	string $constraintNode;
	string $newConstraintTransf;
	
	dSolver; //create dSolver node if necessary
	
	// check selection in scene : one or two rigidBodies should be selected
	int $selSize = size($selection);
	int $selOK = (($selSize == 1) || ($selSize == 2));

	if ($selSize > 2) //more than 2 objects selected
	{
		boingUIUI_constrainMultiple($constraintType);
		return "";
	}
	
	for ($s in $selection) if(`nodeType $s` != "dRigidBody") $selOK = 0;
	
	if(!$selOK)
	{
		boingUIUI_print("Select one or more rigid bodies to create a constraint.", 2);
		return "";
	}
	
	//create constraint node
	switch ($constraintType)
	{
		case 0:
			$constraintNode = `dNailConstraint`;
			break;
		case 1:
			$constraintNode = `dHingeConstraint`;
			break;
		case 2:
			$constraintNode = `dSliderConstraint`;
			break;
		case 3:
			$constraintNode = `dSixdofConstraint`;
			break;
	}
	
	setAttr ($constraintNode + ".disableCollide") `getAttr dSolver1.disableCollisionsBetweenLinkedBodies`;
	$constraintTransforms = `listRelatives -p $constraintNode`;
	$newConstraintTransf = $constraintTransforms[0];
	
	//connect to bodies
	if($selSize == 1)
	{
		connectAttr ($selection[0] + ".message") ($constraintNode + ".inRigidBodyA");
		string $rbTransform[] = `listRelatives -p $selection[0]`;
		float $posA[3] = `getAttr ($rbTransform[0] + ".translate")`;
		float $iWorldA[16] = `getAttr ($rbTransform[0] + ".worldMatrix")`;
		float $pivA[] = boingUIUI_worldToObj($posA, $iWorldA);
		setAttr ($constraintNode + ".pivotInA") -typ float3 $pivA[0] $pivA[1] $pivA[2];
		setAttr ($newConstraintTransf + ".translate") -typ float3 $posA[0] $posA[1] $posA[2];
	}
	else
	{
		connectAttr ($selection[0] + ".message") ($constraintNode + ".inRigidBodyA");
		connectAttr ($selection[1] + ".message") ($constraintNode + ".inRigidBodyB");
		string $rbTransformA[] = `listRelatives -p $selection[0]`;
		string $rbTransformB[] = `listRelatives -p $selection[1]`;
		float $posA[] = `getAttr ($rbTransformA[0] + ".translate")`;
		float $posB[] = `getAttr ($rbTransformB[2] + ".translate")`;
		float $pivW[3];
		//move constraint to midpoint between each rigid body
		$pivW[0] = mbLerpScalar($posA[0], $posB[0], 0.5);
		$pivW[1] = mbLerpScalar($posA[1], $posB[1], 0.5);
		$pivW[2] = mbLerpScalar($posA[2], $posB[2], 0.5);
		float $iWorldA[16] = `getAttr ($rbTransformA[0] + ".worldMatrix")`;
		float $iWorldB[16] = `getAttr ($rbTransformB[0] + ".worldMatrix")`;
		float $pivA[] = boingUIUI_worldToObj($pivW, $iWorldA);
		float $pivB[] = boingUIUI_worldToObj($pivW, $iWorldB);
		setAttr ($constraintNode + ".pivotInA") -typ float3 $pivA[0] $pivA[1] $pivA[2];
		setAttr ($constraintNode + ".pivotInB") -typ float3 $pivB[0] $pivB[1] $pivB[2];
		setAttr ($newConstraintTransf + ".translate") -typ float3 $pivW[0] $pivW[1] $pivW[2];
	}
	select -r $newConstraintTransf;
	return $newConstraintTransf;
}

global proc boingUIUI_constrainMultiple(int $constraintType)
{
	string $sel[] = `ls -sl`;
	string $selTmp[] = $sel;
	string $overlapping[];
	string $nearest[];
	string $constraints[];
	string $newConstraint;
	string $constraintLayer = "boingUIConstraints";
	string $constraintGroup;
	int $constraintCount = 0;

	//filter selection
	for ($s in $sel) if (!mbIsType($s, "dRigidBody")) select -d $s;
	
	$overlapping = mbGetOverlappingTransforms($sel);
	if (size($overlapping))
	{
		boingUIUI_print("Spatial duplicates found and ignored.", 1);
		print("boingUI: overlapping transforms ----------------- :\n");
		print($overlapping);
		select -d $overlapping;
	}

	$sel = `ls -sl`;
	if (size($sel) < 2)
	{
		select -r $selTmp;
		boingUIUI_print("No constrainable rigid bodies in selection", 2);
		return;
	}
	else
	{
		boingUIUI_print("Creating boingUI Constraints...", 0);
		//create groups and layers if necessary
		$constraintGroup = `group -em -n dConstraints`;
		mbHideAndLockTransform($constraintGroup);
		mbCreateLayer($constraintLayer, 0);
	}
	
	//collect and sort RBs
	int $last = size($sel) - 1;
	$nearest = mbDaisyChainObjects($sel, $sel[$last], 0);
	
	for ($i=0;$i<size($nearest)-1;$i++)
	{
		if ($i < (size($nearest)-1)) select -r $nearest[$i] $nearest[$i+1];

		switch ($constraintType)
		{
			case 0:
				$newConstraint = boingUIUI_createConstraint(0);
				break;
			case 1:
				$newConstraint = boingUIUI_createConstraint(1);
				break;
			case 2:
				$newConstraint = boingUIUI_createConstraint(2);
				break;
			case 3:
				$newConstraint = boingUIUI_createConstraint(3);
				break;
		}
		$constraintCount++;
		mbAddToLayer($newConstraint, $constraintLayer);
		parent $newConstraint $constraintGroup;
		$constraints[size($constraints)] = $newConstraint;
		refresh;
	}
	
	select -r $constraints;
	boingUIUI_print("Created " + $constraintCount + " constraints.", 0);
	clear($nearest);
	clear($sel);
	
}

global proc boingUIUI_createRigidBodyArray(int $activebody, int $collisionShapeType)
{
	global float $boingUIUI_startFrame;
	float $mass = 1;
	
	if ($activebody == false) $mass = 0;
	
	global int $boingUIUI_createArrayUI_size[];
	global float $boingUIUI_createArrayUI_offset[];

	if(`layoutDialog -title "Create Rigid Body Array" -ui "boingUIUI_createArrayUI"` == "OK") {    
		string $selection[] = `ls -selection -dag -leaf -showType -type "geometry"`;

		//create dSolver node if necessary
		dSolver;

		string $rigidBodyArrayNode = `dRigidBodyArray`;
		string $collisionShapeNode = `createNode dCollisionShape`;
		connectAttr ($collisionShapeNode + ".outCollisionShape") ($rigidBodyArrayNode + ".inCollisionShape");
		string $rigidBodyTransforms[] = `listRelatives -parent $rigidBodyArrayNode`;
		
		if(size($selection) != 0) {
			string $shapeTransforms[] = `listRelatives -parent $selection[0]`;
			if($selection[1] == "mesh") {
				connectAttr ($selection[0] + ".message") ($collisionShapeNode + ".inShape");
				hide $shapeTransforms[0];
			}
		}
		
		setAttr ($rigidBodyArrayNode + ".mass" ) $mass;
		setAttr ($collisionShapeNode + ".type" ) $collisionShapeType;
		
		select -r $rigidBodyTransforms[0];

		int $size[]= $boingUIUI_createArrayUI_size;
		float $off[]= $boingUIUI_createArrayUI_offset;
		float $x0[];
		$x0[0] = -0.5 * $size[0] * $off[0];
		$x0[1] = -0.5 * $size[1] * $off[1];
		$x0[2] = -0.5 * $size[2] * $off[2];
		setAttr ($rigidBodyArrayNode + ".numBodies") ($size[0] * $size[1] * $size[2]);
		for ($i = 0; $i < $size[0]; $i++) {
			for ($j = 0; $j < $size[1]; $j++) {
				for ($k = 0; $k < $size[2]; $k++) {
					setAttr ($rigidBodyArrayNode + ".initialPosition[" + string($i + $size[0] * $j + $size[0] * $size[1] * $k) + "]") ($x0[0] + $i * $off[0]) ($x0[1] + $j * $off[1]) ($x0[2] + $k * $off[2]);
				}
			}
		}  
		currentTime $boingUIUI_startFrame; //force refresh		
	}
}

global proc boingUIUI_createArrayUIdismissCB(string $button)
{
	global string $boingUIUI_createArrayUI_sizeCT;
	global string $boingUIUI_createArrayUI_offsetCT;

	global int $boingUIUI_createArrayUI_size[];
	global float $boingUIUI_createArrayUI_offset[];

	$boingUIUI_createArrayUI_size = `intFieldGrp -query -value $boingUIUI_createArrayUI_sizeCT`; 
	$boingUIUI_createArrayUI_offset = `floatFieldGrp -query -value $boingUIUI_createArrayUI_offsetCT`; 
	layoutDialog -dismiss $button;
}

global proc boingUIUI_createArrayUI()
{
	global string $boingUIUI_createArrayUI_sizeCT;
	global string $boingUIUI_createArrayUI_offsetCT;

	// Get the dialog's formLayout.
	string $form = `setParent -q`;

	// layoutDialog's are not resizable, so hard code a size here,
	// to make sure all UI elements are visible.
	formLayout -e -width 400 $form;

	string $b1 = `button -l "OK"    -c "boingUIUI_createArrayUIdismissCB(\"OK\")"`;
	string $b2 = `button -l "Cancel"-c "boingUIUI_createArrayUIdismissCB(\"Cancel\")"`;

	$boingUIUI_createArrayUI_sizeCT = `intFieldGrp -columnAlign 1 "left" -adj 1 -numberOfFields 3 -label "Array Size" -v1 3 -v2 3 -v3 3`;
	$boingUIUI_createArrayUI_offsetCT = `floatFieldGrp -columnAlign 1 "left" -adj 1 -numberOfFields 3 -label "Array Offset" -v1 2.0 -v2 2.0 -v3 2.0`;

	formLayout -edit
	-attachForm            $boingUIUI_createArrayUI_sizeCT   "top"    5
	-attachForm            $boingUIUI_createArrayUI_sizeCT   "left"   5
	-attachNone            $boingUIUI_createArrayUI_sizeCT   "bottom"
	-attachForm            $boingUIUI_createArrayUI_sizeCT   "right"  5 

	-attachControl         $boingUIUI_createArrayUI_offsetCT  "top"   5 $boingUIUI_createArrayUI_sizeCT
	-attachForm            $boingUIUI_createArrayUI_offsetCT  "left"   5
	-attachNone            $boingUIUI_createArrayUI_offsetCT  "bottom"
	-attachForm            $boingUIUI_createArrayUI_offsetCT   "right"  5 

	-attachControl         $b1  "top"   5 $boingUIUI_createArrayUI_offsetCT
	-attachForm            $b1  "left"   5
	-attachNone            $b1  "bottom"
	-attachPosition        $b1  "right"  5 33

	-attachControl         $b2  "top"    5 $boingUIUI_createArrayUI_offsetCT
	-attachPosition        $b2  "left"   5 33
	-attachNone            $b2  "bottom"
	-attachPosition        $b2  "right"  5 66

	$form;
}

global proc float[] boingUIUI_worldToObj(float $pointW[], float $objToWorldMatrix[])
{
	float $result[];
	$result[0] = 0.0;
	$result[1] = 0.0;
	$result[2] = 0.0;
	float $offs[];
	if ( size($pointW) != 3 || size($objToWorldMatrix) != 16 )
	{
		warning("Point must be an array of 3 doubles and matrix must be an array of 16 doubles.");
		return $result;
	}
	for ($i = 0; $i < 3; $i++)
	{
		$offs[$i] = $pointW[$i] - $objToWorldMatrix[12 + $i];
	}
	for ($i = 0; $i < 3; $i++)
	{
		for ($j = 0; $j < 3; $j++)
		{
			$result[$i] += $objToWorldMatrix[$i * 4 + $j] * $offs[$j];
		}
	}
	return $result;
}

global proc boingUIUI_activateAxis(int $axis)
{
	global int $boingUIUI_activateAxis; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain
	$boingUIUI_activateAxis = $axis; 
	boingUIUI_activateRigidBodies();
}

global proc boingUIUI_activateRigidBodies() 
{
	global float $boingUIUI_activeStartFrame;
	global float $boingUIUI_activeEndFrame;
	global int $boingUIUI_activateAxis; //0 = +X, 1 = -X, 2 = +Y, 3 = -Y, 4 = +Z, 5 = -Z, 6 = radial out, 7 = radial in, 8 = daisy chain
	global int $boingUIUI_createActivateSet;

	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	string $sorted[];
	float $attrs[];
	string $axis;
	int $reverseAxis = 0;
	int $selChunks;
	string $refr[];
	int $incr = 0;
	int $i;

	//filter selection
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "dRigidBody")) select -add $s; //if dRigidBody
	$sel = `ls -sl`;
	for ($s in $sel) if (mbIsKeyed($s)) select -d $s; //if keyed
	$sel = `ls -sl`;
	$selChunks = (int)size($sel)/10;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		boingUIUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	//we are go!
	boingUIUI_print("Activating " + size($sel) + " rigid bodies...", 0);
	refresh;
	if ($boingUIUI_createActivateSet) sets -n "ActivatedRigidBodies";

	switch ($boingUIUI_activateAxis) 
	{
		case 0: $axis = "tx"; break;
		case 1: $axis = "tx"; $reverseAxis = 1; break;
		case 2: $axis = "ty"; break;
		case 3: $axis = "ty"; $reverseAxis = 1; break;
		case 4: $axis = "tz"; break;
		case 5: $axis = "tz"; $reverseAxis = 1; break;
		case 7: $reverseAxis = 1; break;
		case 8: break;
	}
	
	if ($boingUIUI_activateAxis < 6) //linear axis
	{
		$sorted = mbSortObjectsByAttr($sel, $axis, 0);
		for ($o in $sorted) $attrs[size($attrs)] = `getAttr ($o + "." + $axis)`;
	}
	else if ($boingUIUI_activateAxis == 6 || $boingUIUI_activateAxis == 7)//radial axis
	{
		$sorted = mbProximitySort($sel);
		for ($o in $sorted) $attrs[size($attrs)] = mbDistanceBetweenNodes($sorted[0], $o);
	}
	else if ($boingUIUI_activateAxis == 8) //daisy chain
	{
		boingUIUI_print("Computing chain sequence...", 0);
		int $last = size($sel) - 1;
		$sorted = mbDaisyChainObjects($sel, $sel[$last], 0);
		for ($i=0;$i<size($sorted);$i++) $attrs[size($attrs)] = $i; //mbDistanceBetweenNodes($sorted[$i], $sorted[$i+1]);
	}

	if ($reverseAxis) $sorted = mbReverseStringArray($sorted);
	$attrs = mbScaleArray($attrs, $boingUIUI_activeStartFrame, $boingUIUI_activeEndFrame, 1);

	
	for ($i=0;$i<size($sorted);$i++) 
	{
		float $mass = `getAttr (mbGetShape($sorted[$i]) + ".mass")`;
		if ($mass == 0) $mass = 1;
		cutKey -at "mass" -cl $sorted[$i];
		setKeyframe -at "mass" -t 1 -v 1 $sorted[$i];
		setKeyframe -at "mass" -t 2 -v 0 $sorted[$i];
		setKeyframe -at "mass" -t $attrs[$i] -v $mass $sorted[$i];
		keyTangent -itt "flat" -ott "step" $sorted[$i];
		
		//visual feedback in viewport
		$refr[size($refr)] = $sorted[$i];
		$incr++;
		if ($incr == $selChunks)
		{
			select -r $refr; 
			refresh;
			$incr = 0;
			clear($refr);
			select -cl;
			refresh;
		}
	}

	boingUIUI_print(size($sel) + " rigid bodies activated. Frame range: "
		+ $boingUIUI_activeStartFrame + " - " + $boingUIUI_activeEndFrame, 0);
}

global proc boingUIUI_deactivateRigidBodies(int $toPassive)
{
	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "dRigidBody")) select -add $s; //if dRigidBody
	$sel = `ls -sl`;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		boingUIUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	boingUIUI_print("Removing activation from " + size($sel) + " rigid bodies...", 0);
	refresh;
	
	for ($s in $sel)
	{
		cutKey -at "mass" -cl $s;
		setAttr ($s + ".mass") 1;
		if ($toPassive) setAttr ($s + ".mass") 0;
	}
	
	if ($toPassive)
	{
		boingUIUI_print(size($sel) + " rigid bodies made passive (mass = 0).", 0);
	}
	else
	{
		boingUIUI_print(size($sel) + " rigid bodies made active (mass > 0).", 0);
	}
}

global proc boingUIUI_setInitialState(int $reset)
{	
	global float $boingUIUI_startFrame;
	string $sel[] = `ls -sl`;
	string $selTmp[] = `ls -sl`;
	string $constraints[];
	
	//filter selection
	select -cl;	
	for ($s in $sel) if (mbIsType($s, "dRigidBody")) select -add $s; //if dRigidBody
	$sel = `ls -sl`;
	for ($s in $sel) if (mbIsKeyed($s)) select -d $s; //if keyed
	$sel = `ls -sl`;
	
	if (!size($sel)) 
	{
		select -r $selTmp; //restore original selection
		boingUIUI_print("No rigid bodies found in selection.", 2);
		return;
	}
	
	//we are go!
	boingUIUI_print("Setting initial state for " + size($sel) + " rigid bodies...", 0);
	refresh;

	for ($s in $sel)
	{
		if ($reset)
		{
			$posX = `getAttr ($s + ".originalPositionX")`;
			$posY = `getAttr ($s + ".originalPositionY")`;
			$posZ = `getAttr ($s + ".originalPositionZ")`;
			$rotX = `getAttr ($s + ".originalRotationX")`;
			$rotY = `getAttr ($s + ".originalRotationY")`;
			$rotZ = `getAttr ($s + ".originalRotationZ")`;
			setAttr ($s + ".initialPosition") -typ double3 $posX $posY $posZ;
			setAttr ($s + ".initialRotation") -typ double3 $rotX $rotY $rotZ;
		}
		else
		{
			float $pos[] = `xform -q -ws -t $s`;
			float $rot[] = `xform -q -ws -ro $s`;
			setAttr ($s + ".initialPosition") -typ double3 $pos[0] $pos[1] $pos[2];
			setAttr ($s + ".initialRotation") -typ double3 $rot[0] $rot[1] $rot[2];
		}
		
		//collect connected constraints
		string $conn[];
		$rels = `listRelatives $s`;
		if (size($rels)) $conn = `listConnections $rels`;
		for($c in $conn)
		{
			$shape = mbGetShape($c);
			if (size($shape))
			{					
				if (`nodeType $shape` == "dNailConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dHingeConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dSliderConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
				if (`nodeType $shape` == "dSixdofConstraint" && `objExists $c` == true) $constraints[size($constraints)] = $c;
			}
		}
	}

	currentTime $boingUIUI_startFrame;
	boingUIUI_updateConstraints($constraints);
}

global proc boingUIUI_updateConstraints(string $constraints[])
{
	global float $boingUIUI_startFrame;
	string $sel[];
	
	for ($c in $constraints)
	{
		string $type = mbGetType(mbGetShape($c));
		if ($type == "dNailConstraint") $sel[size($sel)] = $c;
		if ($type == "dHingeConstraint") $sel[size($sel)] = $c;
		if ($type == "dSliderConstraint") $sel[size($sel)] = $c;
		if ($type == "dSixdofConstraint") $sel[size($sel)] = $c;
	}
	
	for ($s in $sel)
	{
		$shape = mbGetShape($s);
		$selection = `listConnections $shape`;
		
		if (size($selection) == 1)
		{
			float $posA[] = `xform -q -ws -t $selection[0]`;
			setAttr ($s + ".translate") -typ float3 $posA[0] $posA[1] $posA[2];
		}
		if (size($selection) == 2)
		{
			float $posA[] = `xform -q -ws -t $selection[0]`;
			float $posB[] = `xform -q -ws -t $selection[1]`;
			float $pivW[3];
			$pivW[0] = mbLerpScalar($posA[0], $posB[0], 0.5);
			$pivW[1] = mbLerpScalar($posA[1], $posB[1], 0.5);
			$pivW[2] = mbLerpScalar($posA[2], $posB[2], 0.5);
			setAttr ($s + ".translate") -typ float3 $pivW[0] $pivW[1] $pivW[2];
		}
	}
}

global proc boingUIUI_bakeRigidBodies()
{
	global int $boingUIUI_deleteEmptyNodes;
	global int $boingUIUI_deleteBakeHistory;
	global int $boingUIUI_optimizeChannels;
	global int $boingUIUI_captureAll;
	global float $boingUIUI_captureStartFrame;
	global float $boingUIUI_captureEndFrame;
	
	string $dBakeLayer = "boingUIBaked";
	string $bakeGroup;
	string $sel[] = `ls -sl`;
	string $toBake[];
	string $preKeyed[];
	string $baked[];
	float $progress;
	int $go = 0;
	
	select -cl;
	
	//select all rigid bodies
	if ($boingUIUI_captureAll) $sel = `ls -tr`;
	for ($s in $sel) if (mbIsType($s, "dRigidBody")) mbAddToSelection($s);
	$sel = `ls -sl`;
	
	//remove prekeyed objects from selection
	for ($s in $sel)
	{
		if (mbIsKeyed($s))
		{
			$preKeyed[size($preKeyed)] = $s;
			select -d $s;
		}
		if (!mbIsType($s, "dRigidBody"))
		{
			select -d $s;
		}
	}
	
	$sel = `ls -sl`;
	if (!size($sel)) 
	{
		select -r $sel;
		boingUIUI_print("No rigid bodies to bake.", 2);
		return;
	}
	
	//confirm
	$confirm = `confirmDialog -t "boingUI: Bake Rigid Bodies" -m "Bake boingUI Simulation?\nThis action is not undoable." 
		-b "Yes" -b "No" -db "Yes" -cb "No" -ds "No"`;
	if ($confirm == "No") 
	{
		select -r $sel;
		boingUIUI_print("Bake cancelled by user.", 1);
		return;
	}
	
	//we are go
	boingUIUI_print("Baking " + size($sel) + "rigid bodies...", 0);
	mbCreateLayer($dBakeLayer, 0);
	if ($boingUIUI_deleteBakeHistory) delete -ch;
	undoInfo -state off;
	select -cl;
	
	//find connected transforms, modify selection
	for ($s in $sel)
	{
		$connectedTransforms = mbGetConnectedTransforms($s);
		if (size($connectedTransforms))
		{
			if (mbIsMesh($connectedTransforms[0])) 
			{
				$toBake[size($toBake)] = $connectedTransforms[0];
				mbAddToLayer($connectedTransforms[0], $dBakeLayer);
			}
		}
		else 
		{
			$toBake[size($toBake)] = $s;
			mbAddToLayer($s, $dBakeLayer);
		}
	}
	
	select -r $toBake;
	
	//bake!
	boingUIUI_print("boingUI: Baking simulation...", 0);
	$baked = `ls -sl`;
	cycleCheck -e off;
	bakeResults 
		-simulation 1 
		-t ((string)$boingUIUI_captureStartFrame + ":" + (string)$boingUIUI_captureEndFrame) 
		-sampleBy 1 
		-disableImplicitControl 1 
		-preserveOutsideKeys 1 
		-sparseAnimCurveBake 0
		-controlPoints 0
		-shape 0
		-at "tx" 
		-at "ty" 
		-at "tz" 
		-at "rx" 
		-at "ry" 
		-at "rz";
	
	select -cl;
	
	//delete orphans
	boingUIUI_print("Removing orphaned rigid bodies and constraints...", 0);
	for ($s in $sel) 
	{
		select -add $s;
		string $conn[];
		$rels = `listRelatives $s`;
		if (size($rels)) $conn = `listConnections $rels`;
		for($c in $conn)
		{
			$shape = mbGetShape($c);
			if (size($shape))
			{					
				if (`nodeType $shape` == "dNailConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dHingeConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dSliderConstraint" && `objExists $c` == true) select -add $c;
				if (`nodeType $shape` == "dSixdofConstraint" && `objExists $c` == true) select -add $c;
			}
		}

		//filter and process primitives
		if (mbIsType($s, "dRigidBody"))
		{
			$connectedTransforms = mbGetConnectedTransforms($s);
			string $connectedCollisionShape = mbGetConnectedByType(mbGetShape($s), "dCollisionShape");
			if (!size($connectedTransforms))
			{
				select -d $s;
				setAttr ($s + ".mass") 0;
			}
		}
		
		dgeval `mbGetShape($s)`;
	}

	$sel = `ls -sl`;
	if (size($sel))
	{
		boingUIUI_print(size($sel) + " orphans found, deleting...", 0);
		delete;
	}
	
	if ($boingUIUI_optimizeChannels) 
	{
		boingUIUI_print("Optimizing channels...", 0);
		//delete -staticChannels -uac 0 -hi none -cp 0 -s 0; //brute force - kills all static channels in scene
		for ($b in $baked)
		{
			if (size($preKeyed)) 
			{
				for ($p in $preKeyed)
				{
					if ($b != $p)
					{
						delete -staticChannels -uac 0 -hi none -cp 0 -s 0 $b;
						break;
					}
					else
					{
						break;
					}
				}
			} 
			else 
			{
				delete -staticChannels -uac 0 -hi none -cp 0 -s 0 $b;
			}
			
			filterCurve -f simplify -timeTolerance 0 -tol 0.0001 {$b + ".rotateY", $b+ ".rotateX", $b + ".translateZ", $b + ".translateY", $b + ".translateX", $b + ".rotateZ"};
		}
	}

	if ($boingUIUI_deleteEmptyNodes)
	{
		boingUIUI_print("Removing empty nodes...", 0);
		mbDeleteEmptyNodes();
	}

	if ($boingUIUI_deleteBakeHistory)
	{
		boingUIUI_print("Removing history...", 0);
		delete -all -ch;
		
		for ($b in $baked) mbDeleteShapeHistory($b); //clean shape history
	}
	
	undoInfo -state on;
	select -r $baked;
	$bakeGroup = `group -em -n dBaked`;
	for ($b in $baked) parent $b $bakeGroup; //move to baked group
	boingUIUI_print("Baked " + size($baked) + " rigid bodies on frames " + $boingUIUI_captureStartFrame + " - " + $boingUIUI_captureEndFrame, 0);
}

//callbacks
global proc int bulletExportOptions( string $parent, string $action, string $settings, string $callback ) 
{
	return 1;
}

//script jobs
global proc boingUIUI_syncSolver()
{
	if (`objExists dSolver1`)
	{
		global float $boingUIUI_startFrame;
		float $startFrame = `playbackOptions -q -min`;
		setAttr "dSolver1.startTime" $startFrame;
		$boingUIUI_startFrame = $startFrame;
		boingUIUI_print("Updated solver Start Time to: " + (string)$boingUIUI_startFrame, 0);
	}
}

global proc boingUIUI_onSceneOpen()
{
	global int $boingUIUI_syncSolverJob = -1;
	if (!`scriptJob -ex $boingUIUI_syncSolverJob`)
	{
		$boingUIUI_syncSolverJob = `scriptJob -kws -e "playbackRangeChanged" boingUIUI_syncSolver`;
	}
}

global proc boingUIUI_onPluginLoad()
{
	global int $boingUIUI_sceneOpenJob = -1;
	if (!`scriptJob -ex $boingUIUI_sceneOpenJob`)
	{
		$boingUIUI_sceneOpenJob = `scriptJob -e "SceneOpened" boingUIUI_onSceneOpen`;
	}
	
	boingUIUI_onSceneOpen();
}

